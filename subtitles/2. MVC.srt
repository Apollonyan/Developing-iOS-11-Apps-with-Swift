1
00:00:00,401 --> 00:00:04,636
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:04,705 --> 00:00:10,375
Stanford University. >> Welcome to Stanford CS193P,
欢迎参加斯坦福 CS193P 课程

3
00:00:10,444 --> 00:00:15,013
Developing Applications for iOS. This is Lecture Number 2,
iOS 应用程序开发。今天是 2017 年秋季学期

4
00:00:15,081 --> 00:00:19,451
fall of 2017. So today, I'm gonna spend the first 15 or
的第二节课。今天我要先花十五到

5
00:00:19,520 --> 00:00:22,053
20 minutes talking about Model-View-Controller,
二十分钟的时间讲 Model-View-Controller

6
00:00:22,122 --> 00:00:25,790
this design paradigm that I told you we always have to do
这个设计模式，我说的我们总是需要

7
00:00:25,859 --> 00:00:29,595
when we develop for iOS. And then, we're gonna apply
在开发 iOS 时用的设计模式。然后我们把

8
00:00:29,663 --> 00:00:32,964
Model-View-Controller to our Concentration app, so
模型-视图-控制器 运用到翻牌游戏里

9
00:00:33,033 --> 00:00:35,734
you're gonna get to see the kinda the concepts first,
你会先了解下这个概念

10
00:00:35,802 --> 00:00:38,903
then we get to see it in action. All right,
然后我们看实际的应用。那么

11
00:00:38,972 --> 00:00:42,841
Model-View-Controller, what is it? It's essentially a way
模型-视图-控制器 究竟是什么呢？它是一种

12
00:00:42,909 --> 00:00:46,444
we're gonna divide up all the objects in our system into
在我们的系统里把对象分类的方法

13
00:00:46,513 --> 00:00:52,250
three camps. one camp, this blue camp, is the Model camp.
分成三个阵营。一个是这个蓝色的 Model，模型

14
00:00:52,319 --> 00:00:56,521
That's a UI independent set of objects that is
这是不依赖于 UI 的一系列对象，这代表了

15
00:00:56,589 --> 00:01:00,959
the what of your app? So for our Concentration game, it's
你的程序究竟能做什么。对于我们的翻牌游戏

16
00:01:01,027 --> 00:01:03,996
the part of our app that knows how to play Concentration.
就是程序里知道翻牌游戏规则的那部分

17
00:01:04,064 --> 00:01:06,164
It knows how to match cards, take them away,
它知道怎么匹配卡片，移走

18
00:01:06,233 --> 00:01:09,033
it knows when to flip cards, it knows all that stuff.
知道什么时候翻牌，知道所有这些

19
00:01:09,102 --> 00:01:11,803
It's all the kind of knowledge about the Concentration
它知道所有翻牌游戏相关的的信息和规则

20
00:01:11,872 --> 00:01:15,807
game but nothing about how it appears on screen. That
但是并不知道这是怎么显示在屏幕上的

21
00:01:15,876 --> 00:01:19,311
is all part of the Controller camp's responsibility.
那个就属于 Controller，控制器的职责了

22
00:01:19,379 --> 00:01:21,747
So the Controller camp is the how
控制器阵营的是负责

23
00:01:23,083 --> 00:01:25,984
your Concentration game appears on screen.
你的翻牌游戏如何显示到屏幕上

24
00:01:26,053 --> 00:01:28,587
So Model is what is your app about, and
所以模型是代表程序是做什么的

25
00:01:28,655 --> 00:01:31,923
the Controller is how it shows up on screen.
控制器是程序是怎么显示到屏幕上的

26
00:01:31,992 --> 00:01:35,994
And the View camp is your Controller's minions.
然后 View，视图阵营就是控制器的下属

27
00:01:36,063 --> 00:01:41,333
These are very generic UI elements, like UI button,
他们是通用的 UI 组件，比如 UIButton

28
00:01:41,402 --> 00:01:45,104
the UI view controller even UI label.
甚至 UIViewController，还有 UILabel

29
00:01:45,172 --> 00:01:48,173
All those kind of generic things, UI things,
所有这些通用的 UI 组件

30
00:01:48,241 --> 00:01:52,644
that the Controller has to communicate with the Model to
在控制器与模型交流过后

31
00:01:52,712 --> 00:01:58,149
get your game, whatever is going on your app onto the UI.
得到了游戏一类的信息，就会用视图显示出来

32
00:01:58,218 --> 00:02:02,086
So the View is generic minions of the Controller. So
所以视图是通用的，控制器的下属

33
00:02:02,155 --> 00:02:06,524
those are the three camps. Now, MVC is really all about
这就是模型-视图-控制器三个阵营，简称 MVC

34
00:02:06,593 --> 00:02:09,294
managing the communication between these camps, right?
但最重要的是规范这三个阵营之间的通讯

35
00:02:09,363 --> 00:02:10,628
You put the objects in these camps, and
你把对象分到这三个阵营里了

36
00:02:10,697 --> 00:02:13,598
they have to kind of obey certain rules when they talk
那他们之间交谈就要遵守一定的规则

37
00:02:13,667 --> 00:02:16,501
to each other. So, I've drawn road signs up here.
所以我这里用道路交通标线来表明

38
00:02:16,570 --> 00:02:19,871
You see the little road signs that are kind of approximating
看到这个道路交通标线了吗？它们表示了

39
00:02:19,940 --> 00:02:22,908
what kind of communication is allowed between the various
这几个阵营之间被允许的沟通

40
00:02:22,977 --> 00:02:25,943
camps. And let's look at it all in detail. So
让我们来仔细看看

41
00:02:26,012 --> 00:02:28,079
the Controller, talking to the Model,
所以这个控制器可以访问模型

42
00:02:28,148 --> 00:02:31,716
that's a fully dashed white line going in that direction.
向这个方向的是一条白色的虚线

43
00:02:31,785 --> 00:02:35,254
You can cross over anytime you want, big green arrow.
任何时候都可以穿过去，我用绿色箭头表示

44
00:02:35,322 --> 00:02:38,022
The Controller can talk to the Model all it wants.
这个控制器可以随便和模型交流

45
00:02:38,091 --> 00:02:41,393
It has to be able to because it is the Controller's job to
它必须要能这样做，因为这是控制器的工作

46
00:02:41,462 --> 00:02:45,563
present this what the thing is to the user, so it has to be
就是把模型展示给用户，所以必须要

47
00:02:45,632 --> 00:02:48,433
able to access the Model. So that's a big old green arrow,
能够访问模型，所以这是个肯定可以的绿色箭头

48
00:02:48,502 --> 00:02:51,803
and this is the Controller talking to the Model.
控制器是可以访问模型的

49
00:02:51,871 --> 00:02:57,609
Pretty much unlimited communication to the Model's
访问模型基本没有限制

50
00:02:57,678 --> 00:03:00,913
publicly available functionality. What about this
只要是公开可用的功能都行。那这边呢？

51
00:03:00,981 --> 00:03:03,815
direction? Well, similarly here, its minions,
这边也是类似的，视图是下属

52
00:03:03,883 --> 00:03:06,584
the Controller has to be able to control its minions, so
控制器需要能控制它的下属，所以

53
00:03:06,653 --> 00:03:09,554
it's a pretty much a wide open green arrow that way as well,
这也是可以的，我这个方向也用绿色箭头表示

54
00:03:09,623 --> 00:03:11,689
and you've already seen a green arrow from
而且你已经看到了这样的“绿色通道”了

55
00:03:11,758 --> 00:03:14,225
the Controller to the View in our Concentration.
在翻牌游戏里，从控制器到视图

56
00:03:14,294 --> 00:03:17,162
It was called an outlet. We had an outlet to the flip
就是我们的出口（outlet），我们有一个到

57
00:03:17,230 --> 00:03:19,964
count label, and of course we can talk to the flip count
flipCountLabel 的出口，当然我们可以告诉 flipCountLabel

58
00:03:20,033 --> 00:03:23,067
label and say anything we want to it to get it to say what we
说我们想要让他在 UI 上显示

59
00:03:23,136 --> 00:03:26,037
want in the UI. That is the Controller's prerogative.
我们想要的内容。这就是控制器的特权

60
00:03:26,106 --> 00:03:28,673
So you can see the controller can talk to everybody
你看到了，所以控制器能和所有人交谈

61
00:03:28,742 --> 00:03:31,977
pretty much all at once. What about some of the other kind
基本都可以。那这些其他之间的

62
00:03:32,046 --> 00:03:34,612
of communication? What about the Model talking
通讯呢？比如模型

63
00:03:34,681 --> 00:03:39,250
directly to the View? Okay, that's pretty much impossible.
直接访问视图呢？好吧，这个基本是不可能的

64
00:03:39,319 --> 00:03:41,153
Why is that impossible? Two reasons.
为什么不可能呢？有两个理由

65
00:03:41,221 --> 00:03:44,989
One, the Model is UI independent, and the View only
其一，模型是和 UI 无关的，而视图

66
00:03:45,058 --> 00:03:47,793
has UI things in it, so there's absolutely no way a UI
只负责显示 UI。所以没有可能一个

67
00:03:47,861 --> 00:03:51,496
independent thing could talk to such UI dependent things
无关 UI 的阵营去访问这个只是 UI

68
00:03:51,564 --> 00:03:54,866
like the View. Another reason is that these View things
的视图。另一个原因是视图

69
00:03:54,935 --> 00:03:58,603
are generic objects, like a button or a slider. How could
都是通用的，比如按钮或是滑杆

70
00:03:58,672 --> 00:04:01,939
a button have any idea what a Concentration game is about?
一个按钮怎么可能知道翻牌游戏是干什么的？

71
00:04:02,008 --> 00:04:04,075
No way. There's just no way it would know that, it's generic.
不可能。按钮是通用的，它不可能知道翻牌这个游戏

72
00:04:04,144 --> 00:04:06,578
So there's never any communication between these
所以这两个之间是不可能沟通的

73
00:04:06,646 --> 00:04:09,113
two, I never wanna see you having any communication
我不希望看到你在作业里面

74
00:04:09,182 --> 00:04:11,516
between these camps in any of your homeworks or whatever.
让这两个阵营之间沟通

75
00:04:11,585 --> 00:04:13,318
That's why it's a double yellow line there.
这就是为什么这里是双黄线

76
00:04:13,387 --> 00:04:16,755
No crossing over. All right, that's an easy one. What about
不能跨过去。好，这个简单

77
00:04:16,823 --> 00:04:20,158
the View talking back to the Controller? This is probably
那视图翻过去通知控制器呢？这个可能

78
00:04:20,226 --> 00:04:25,029
the most interesting of the communication pathways here.
是最有趣的交流的方法了

79
00:04:25,098 --> 00:04:28,099
The View can speak to its Controller, of course it,
视图是肯定可以通知控制器的

80
00:04:28,168 --> 00:04:31,602
it kind of has to, like when a button is clicked or whatever,
某种意义上这是必须的，比如按钮被按下一类的

81
00:04:31,671 --> 00:04:33,204
but when it communicates,
但是他们要交流的话

82
00:04:33,273 --> 00:04:36,608
this communication has to be blind and structured. It
这种交流必须要是某种标准化的匿名通讯机制

83
00:04:36,676 --> 00:04:40,145
has to be blind because these are generic view objects.
说它是“匿名的”是因为视图是通用的对象

84
00:04:40,213 --> 00:04:43,014
The UI Button doesn't know anything about a Concentration
UIButton 不知道有关翻牌

85
00:04:43,082 --> 00:04:46,050
game controller, so when it's talking to the Controller,
这个游戏的控制器，所以当它通知控制器的时候

86
00:04:46,119 --> 00:04:48,252
it doesn't really know that it's a Concentration game
它是不知道那是翻牌游戏的

87
00:04:48,321 --> 00:04:50,488
controller and it's structured in that
控制器。说它是有标准的

88
00:04:50,557 --> 00:04:52,857
since we're gonna have this communication going on,
是因为我们要让这个通讯成立

89
00:04:52,926 --> 00:04:56,294
a generic object has to think a little bit ahead about how
一个通用的对象要提前考虑好

90
00:04:56,363 --> 00:05:00,232
it might wanna communicate with this Controller object.
要如何和控制器对象沟通

91
00:05:00,300 --> 00:05:03,067
So, you already know one structured, blind way for
你们已经见过了一个视图使用的

92
00:05:03,136 --> 00:05:06,471
your View to communicate, and that's target action.
标准化的匿名通讯，那就是 target action

93
00:05:06,540 --> 00:05:09,607
When we Ctrl dragged and created the method touchCard.
当我们按住 control 拖拽，创建了一个方法 touchCard

94
00:05:09,676 --> 00:05:12,344
That's target action. And all the Controller has to do is
这就是目标对象操作。而控制器所要做的

95
00:05:12,412 --> 00:05:16,081
kinda hang a target on itself. That's to say, it creates
就是把自己设为目标对象，也就是创建

96
00:05:16,150 --> 00:05:19,518
a method like touchCard. And then UI button and
一个 touchCard 这样的方法，然后 UIButton

97
00:05:19,586 --> 00:05:21,453
other things, they can get this action, and
一类的控件就能得到操作这个方法的存根

98
00:05:21,521 --> 00:05:22,887
every time the button is pressed,
然后每次按下按钮

99
00:05:22,956 --> 00:05:25,723
they just call the target. This is a very,
按钮就调用目标对象的方法。这是一种非常

100
00:05:25,792 --> 00:05:30,162
very simple kind of blind structure communication. But
非常简单的标准化匿名通讯

101
00:05:30,230 --> 00:05:33,165
sometimes you need more complicated communication,
但有的时候你需要更复杂的通讯

102
00:05:33,233 --> 00:05:35,867
like you have a more complicated generic view
比如你有更复杂的通用 UI 组件

103
00:05:35,936 --> 00:05:39,103
item like, let's say a scroll view. A scroll view is
比如一个 scroll view，滚动视图能够

104
00:05:39,172 --> 00:05:42,407
scrolling around on some image or something like that, and
四处移动来查看一张图片一类的

105
00:05:42,476 --> 00:05:44,409
it might need to tell the Controller,
它可能需要告诉控制器

106
00:05:44,477 --> 00:05:48,513
I scrolled to the end. Am I allowed to scroll down here?
我滚动到最底部了，我还能继续往下么？

107
00:05:48,582 --> 00:05:50,415
Can I scroll vertically or horizontally?
我移动的方向是竖着还是横着？

108
00:05:50,483 --> 00:05:53,084
It kinda wants to talk to Controller as it's
他会想要在完成任务期间

109
00:05:53,152 --> 00:05:57,255
working to do its job. And we do that with these kind of
和控制器保持沟通。为了实现这个，我们会用

110
00:05:57,324 --> 00:06:00,992
predefined methods that the scroll view defines as part of
滚动视图规定好的一些方法，这些方法

111
00:06:01,061 --> 00:06:06,130
what's called its delegate. So its delegate is just a var in
属于 delegate，代理的一部分。代理就是一个变量

112
00:06:06,199 --> 00:06:11,036
scroll view that, and this var will have some object in it.
滚动视图里的一个变量，这个变量存储了一个对象

113
00:06:11,104 --> 00:06:13,872
And all we know about this object is that it responds to
对于这个对象，我们所知道的只有

114
00:06:13,941 --> 00:06:16,441
a certain number of messages. Most of these messages
它能够响应一定数量的某些方法。大部分这些方法

115
00:06:16,510 --> 00:06:18,710
start with the words will, should, or did.
都会以 will, should 或 did 开头

116
00:06:18,778 --> 00:06:21,979
Like, I will scroll to here, should I scroll over here? I
比如我将要（will）滚动到这里，是否能够（should）滚动到那里？

117
00:06:22,048 --> 00:06:26,585
did scroll down to here. Those are classic delegate methods.
我已经（did）滚动到这里了，这些就是典型的代理的方法

118
00:06:26,653 --> 00:06:29,687
And the Controller, using a mechanism called protocols,
然后控制器通过 protocol，协议

119
00:06:29,756 --> 00:06:31,455
which we'll talk about next week,
这个我们下周讲

120
00:06:31,524 --> 00:06:33,458
is able to tell the scroll view,
就能告诉滚动视图

121
00:06:33,527 --> 00:06:36,528
I'm your delegate, and all the scroll view will know
我是你的代理，然而滚动视图只知道

122
00:06:36,596 --> 00:06:38,562
is that it implements these will, should, and did.
我实现了这些 will，should，did 方法

123
00:06:38,631 --> 00:06:40,966
It doesn't know anything about it. It doesn't know its class,
滚动视图不知道其他我的信息，不知道究竟是哪个类

124
00:06:41,034 --> 00:06:43,568
doesn't know that it's has to do with Concentration game
不知道是否是我们的翻牌游戏

125
00:06:43,637 --> 00:06:46,170
obviously, it knows nothing. It just knows that
显然什么也不知道，只知道

126
00:06:46,239 --> 00:06:48,506
the Controller will implement that. So
这个控制器实现了代理方法

127
00:06:48,575 --> 00:06:52,043
we'll see delegation in about two weeks when we start using
我们会在大约两周之后看到代理模式，就是当我们

128
00:06:52,111 --> 00:06:56,214
more complicated UI objects. Now, another important thing
开始使用更加复杂的 UI 对象的时候。另外一个重要的是

129
00:06:56,283 --> 00:06:58,717
to remember in the MVC model is that views,
记住在 MVC 模式里，视图

130
00:06:58,785 --> 00:07:00,085
these generic things,
这些通用的视图

131
00:07:00,153 --> 00:07:03,388
cannot own the data they're displaying. In other words,
不能自己提供他们显示的数据，也就是说

132
00:07:03,456 --> 00:07:06,157
they're not going to have the data they're displaying as
他们不能写死显示的数据，然后作为

133
00:07:06,225 --> 00:07:09,460
part of their instance variables. Now why is this?
实例变量的一部分（伴随每个对象）。为什么呢？

134
00:07:09,529 --> 00:07:13,064
Well, imagine that the View is showing your entire iPod music
让我们现象一下你展示整个 iPod 音乐库

135
00:07:13,133 --> 00:07:17,268
library. And let's say you have 50,000 songs in there.
比如说我们里面有五万首歌

136
00:07:17,337 --> 00:07:20,471
There's no way, it would make absolutely no sense to have
我们不可能，而且也根本没有理由

137
00:07:20,540 --> 00:07:23,475
a list view or something, some generic view that lists
让某个列表视图，某种展示某个列表的通用视图

138
00:07:23,543 --> 00:07:27,345
things, to bring all 50,000 of those things in there. So
存储五万首歌在里面

139
00:07:27,413 --> 00:07:30,648
instead, it uses this same kind of protocol mechanism to
取而代之，应该使用类似的某种协议

140
00:07:30,717 --> 00:07:32,984
have another set of special messages,
让另一些特殊的方法

141
00:07:33,052 --> 00:07:36,353
and they are messages like data, give me the data at, or
这些方法包括给我在这个地方的数据

142
00:07:36,422 --> 00:07:39,891
how many items are there? And the Controller implements that
或者是一共有多少个项目要显示，然后控制器实现这些方法

143
00:07:39,960 --> 00:07:43,628
so we can talk to the Model and get the data for the View.
控制器通过访问模型来获取视图需要的数据

144
00:07:43,697 --> 00:07:47,832
So, for example, table view, which is a big scrolling list
比如列表视图（table view），就是个很长的滚动列表

145
00:07:47,901 --> 00:07:51,269
kind of generic view item, that's in iOS.
这个是 iOS 提供的通用视图组件

146
00:07:51,338 --> 00:07:53,671
When it's scrolling around on all your iPad music things,
当你在来回滑动查看 iPad 音乐库内容的时候

147
00:07:53,740 --> 00:07:56,441
it's just asking for the ones it's currently showing. Right,
它就会去请求正在显示的那些歌曲

148
00:07:56,510 --> 00:07:58,576
there's 50,000. It's only scrolling around to
一共有五万首，来回滑动的话

149
00:07:58,645 --> 00:08:00,978
showing maybe 10 at a time. And so it's just asking
每次大概只会显示十首，它就是去让

150
00:08:01,047 --> 00:08:02,446
the controller give me the next ten,
控制器给它接下来的十首

151
00:08:02,515 --> 00:08:03,848
give me the ten here, and
给我这里的十首歌，然后

152
00:08:03,917 --> 00:08:05,549
the controller turns around to the model,
控制器就转过去问模型

153
00:08:05,618 --> 00:08:08,586
which is probably a nice fast SQL database or something, and
可能是很快的 SQL 数据库一类的

154
00:08:08,655 --> 00:08:11,489
grabbing the data, and handing it off to the view. Okay, and
抓取这些数据，然后传递给视图

155
00:08:11,558 --> 00:08:14,259
this uses the same mechanism where the table view again
这种方法同样的，列表视图

156
00:08:14,327 --> 00:08:16,894
doesn't know anything about this as being an iPod
也是不知道这些数据来源，不知道是不是 iPod

157
00:08:16,963 --> 00:08:20,364
music app, it just knows that it's the data provider, and
音乐程序，只知道它能提供数据

158
00:08:20,433 --> 00:08:24,202
we call this kind of delegate the data source. All right, so
我们叫这种代理 data source，数据源

159
00:08:24,271 --> 00:08:26,637
you'll see that as well, and both data source and delegate,
之后你也会看到。数据源和代理

160
00:08:26,706 --> 00:08:29,207
very similar it's just kind of a different set of methods,
这两个很类似，只是是两套不同的方法

161
00:08:29,276 --> 00:08:32,076
and these methods are of course dependent on the kind
当然这些方法取决于具体的

162
00:08:32,145 --> 00:08:36,114
of UI element, they're not a preset list, depends on what's
UI 组件，并不是固定的，取决于

163
00:08:36,182 --> 00:08:39,917
going on in that UI element. So that's the kind of
那个 UI 组件是干什么的。所以这就是

164
00:08:39,986 --> 00:08:42,920
communication the view can have with the controller,
视图到控制器的通讯

165
00:08:42,989 --> 00:08:46,625
it's structured, it's kind of predefined, things like that.
它是有标准的，提前制定好的

166
00:08:46,693 --> 00:08:49,894
Because of all this communication going on in this
因为这个方向的所有这些通讯

167
00:08:49,962 --> 00:08:53,164
direction we say the controller's job in an MVC is
我们说控制器在 MVC 里的作用

168
00:08:53,232 --> 00:08:56,500
to interpret and format the models information for
是把模型的信息翻译成某种格式

169
00:08:56,569 --> 00:08:59,203
the view. That's its primary purpose.
提供给视图，这就是它主要的目的

170
00:08:59,272 --> 00:09:01,239
It kind of also goes the other way,
反方向它也要处理

171
00:09:01,307 --> 00:09:04,742
It interprets user interaction in the view for the model.
把视图里的用户交互翻译成模型里的数据

172
00:09:04,811 --> 00:09:06,344
It's the interpreter back and forth.
它负责当来回通讯的翻译

173
00:09:06,413 --> 00:09:11,382
It's the center of all communication here.
是所有交流的中心

174
00:09:11,451 --> 00:09:14,585
What about the model? Can the model talk to its controller?
那模型呢？模型能通知控制器吗？

175
00:09:14,654 --> 00:09:19,623
Obviously not directly. Because the model is UI
肯定不是直接的，因为模型是与 UI

176
00:09:19,692 --> 00:09:23,094
independent and the controller is fundamentally UI dependant,
无关的，而控制器根本上讲是取决于 UI 的

177
00:09:23,162 --> 00:09:25,830
so it can't do it directly. But there is a mechanism for
所以不能直接沟通。但是有一种方法

178
00:09:25,899 --> 00:09:29,167
the model to communicate, for example, if some data changes
让模型能够在比如数据发生改变的时候发出通知

179
00:09:29,235 --> 00:09:32,036
and it wants any UIs that are interested out there
好让任何其他对此感兴趣的 UI

180
00:09:32,105 --> 00:09:36,007
to update. And the way it does that is with a model that I
更新，它实现的这种方法我

181
00:09:36,076 --> 00:09:39,277
call radio station model, and the model essentially
把它叫做电台模式。基本上就是模型

182
00:09:39,346 --> 00:09:42,113
starts broadcasting on a certain known radio station.
在某个已知的电台上开始广播

183
00:09:42,182 --> 00:09:46,117
And the controller up there it's just going to tune in and
而上面的控制器就会收听这个电台

184
00:09:46,185 --> 00:09:49,186
when it hears oh something's changed on the models radio
然后听到模型电台说，发生改变的时候

185
00:09:49,255 --> 00:09:51,689
station then it's gonna use its big green arrow,
那控制器就用它的“绿色通道”

186
00:09:51,758 --> 00:09:54,025
to go talk to the model and get the date of the change, or
来访问模型，然后获得改变了的数据

187
00:09:54,093 --> 00:09:57,161
whatever. So this is a radio station model. In iOS
之类的。所以它用的是类似于电台的机制。iOS 里

188
00:09:57,230 --> 00:10:01,399
it's called notifications, or KVO, Key Value Observing, and
这叫做 notification，通知。或者 KVO，键值监听，Key Value Observing

189
00:10:01,468 --> 00:10:05,103
we'll talk about those in a few weeks as well. So there is
这个我们几周之后也会讲。所以我们有

190
00:10:05,172 --> 00:10:08,405
a way from the model to kind of broadcast, wow things
一种方法让模型来广播说

191
00:10:08,474 --> 00:10:13,544
are changing. Now, some people have asked can a view tune in
这些发生了改变。有些人问视图能够收听

192
00:10:13,613 --> 00:10:16,748
to a radio station? A View could only really tune into
某个电台吗？真要说的话，视图只能收听

193
00:10:16,816 --> 00:10:19,918
a controller radio station like another UI thing, cuz
控制器的电台，或者某种 UI 相关的东西

194
00:10:19,986 --> 00:10:23,187
a view is fundamental of UI, but even that's pretty rare.
因为视图是 UI 的基础，但即使有的话也是很罕见

195
00:10:23,256 --> 00:10:24,722
Usually the radio stations are pretty much for
通常电台是用来让

196
00:10:24,791 --> 00:10:27,892
the model to communicate hey something's happening in your
模型用来交流说你的数据发生了变动

197
00:10:27,961 --> 00:10:35,099
data or whatever. This, MVC, a collection of MVC, is
这类的。这个 MVC，这个模型，视图，控制器的集合

198
00:10:35,168 --> 00:10:39,437
generally only used to control one screen on the iPhone, or
一般只会用来控制 iPhone 上的一个界面

199
00:10:39,506 --> 00:10:42,941
on the iPad. Maybe it can control little sub-place,
或者 iPad 上的一个界面。可能可以控制某个附属的界面

200
00:10:43,009 --> 00:10:46,344
like maybe on an iPad, maybe one MVC controls one space,
比如像在 iPad 上，可能一个 MVC 控制一个界面

201
00:10:46,413 --> 00:10:49,046
and another MVC controls another place, and
另一个 MVC 控制另一个界面

202
00:10:49,115 --> 00:10:52,050
possibly a third MVC controls another space, but
然后可能第三个控制另一个界面，但是

203
00:10:52,118 --> 00:10:55,453
you would never have more than one screen, in an iPhone,
但是在 iPhone 上你不会有多个界面

204
00:10:55,521 --> 00:10:59,557
controlled by a single MVC. So the MVC kind of goes with
是由一个 MVC 同时控制的。所以 MVC 还会

205
00:10:59,625 --> 00:11:03,394
a grouping of UI. Usually one screen, one iPhone screen
把 UI 分组，通常是一个界面，一个 iPhone

206
00:11:03,463 --> 00:11:07,731
size worth of stuff. So most apps have tons of screens.
屏幕那么多的内容 。所以大部分程序都有很多个界面

207
00:11:07,800 --> 00:11:10,735
You got your settings, you got all the different features in
你有设置界面，不同的功能

208
00:11:10,804 --> 00:11:13,405
your app, tons and tons of screens going on. So
你的程序里有很多很多的界面

209
00:11:13,473 --> 00:11:16,641
how do we build an app out of multiple MVCs?
那我们如何用多个 MVC 来构建一个程序呢？

210
00:11:18,311 --> 00:11:22,913
Multiple MVC apps look like this. I have a bunch of MVCs
多个 MVC 的程序看起来是这样的。我有很多个 MVC

211
00:11:22,982 --> 00:11:25,082
upright. All those purple things
所有这些紫色的

212
00:11:25,151 --> 00:11:29,120
are all the controllers, and when one MVC wants to interact
是所有的控制器。当一个 MVC 想要和

213
00:11:29,189 --> 00:11:33,124
with another MVC like right here, you see this right here,
另一个 MVC 交互的话，比如，你看这里这个

214
00:11:33,192 --> 00:11:36,961
it always treats those other MVCs as part of its view. So
它总是把那个 MVC 当作是它的视图

215
00:11:37,030 --> 00:11:41,866
these three MVCs down here are part of the view of this MVC.
所以下面这三个 MVC 是这个 MVC 的视图

216
00:11:43,402 --> 00:11:46,804
So it has to talk to them in a blind and structured way.
所以它需要用标准化的匿名方式交流

217
00:11:46,873 --> 00:11:51,108
These kind of act like generic, reusable components,
这些就像是通用的，可重用的组件

218
00:11:51,177 --> 00:11:54,278
and we're gonna see how that works when we
我们将会看到这个是怎么运作的

219
00:11:54,347 --> 00:11:58,950
start talking about multiple MVC apps, a week from Monday.
周一之后过了一周我们就会开始讲多个 MVC 的程序

220
00:11:59,018 --> 00:12:02,019
Now the main thing that we wanna do here is not build our
注意我们讲主要的目的是让你不要编写

221
00:12:02,088 --> 00:12:05,222
multiple MVC apps like this, where there's just green
一个像这样的多个 MVC 的程序

222
00:12:05,291 --> 00:12:08,993
arrows talking everywhere, and the reason we don't want this,
绿色箭头到处都是。我们不想要这个的原因是

223
00:12:09,061 --> 00:12:12,463
it is impossible to debug and find out what is going on
我们不可能调试这个，然后找出问题所在

224
00:12:12,532 --> 00:12:15,733
inside our app, because if something changes in the UI,
在我们的程序里，如果 UI 发生了改变

225
00:12:15,802 --> 00:12:18,536
we don't know which controller was doing it, or
我们不知道是哪个控制器干的

226
00:12:18,604 --> 00:12:22,473
what model gave the data. We're just totally lost. So by
或者是哪个模型提供的数据。我们会毫无头绪

227
00:12:22,542 --> 00:12:25,543
grouping them into these nice MVCs each screen on the phone
所以通过把他们分组成为很好的 MVC，每个手机上的界面

228
00:12:25,612 --> 00:12:29,013
is very well contained and understandable, debugable,
都是隔离开的，而且方便理解和调试

229
00:12:29,081 --> 00:12:34,051
manageable. Everybody got all that? So we're
是可管理的。大家都清楚了吧？所以我们

230
00:12:34,120 --> 00:12:38,956
not gonna do things this way. This is do not do it this way.
不会先这样随意交流，千万不要这样做

231
00:12:39,025 --> 00:12:40,725
Okay so the demo that I'm gonna do.
所以我要演示的是

232
00:12:40,794 --> 00:12:42,260
We're going to do our concentration game.
我们会接着完成翻牌游戏

233
00:12:42,328 --> 00:12:43,761
I'm just gonna create the model and
我会创建一个模型，然后

234
00:12:43,830 --> 00:12:45,396
we're gonna hook the model up into it.
把模型整合进来

235
00:12:45,464 --> 00:12:47,331
Along the way we're gonna learn all these other things.
同时我们会学习其他这些知识点

236
00:12:47,400 --> 00:12:50,635
Again, this is a slide you go look at after the demo to make
同样的，这张幻灯片是给你们之后看的

237
00:12:50,704 --> 00:12:52,336
sure you learn these things.
用来确认你收否学习到了这些

238
00:12:52,405 --> 00:12:54,238
I won't get back to the slides. So once again,
我不会再回来讲幻灯片。那么

239
00:12:54,307 --> 00:12:57,909
what's coming up, don't forget that Friday section at 11:30,
之后的安排，不要忘了周五的课是十一点半

240
00:12:57,977 --> 00:13:00,911
on Friday, about Xcode and debugging, and then next week
星期五是关于 Xcode 和调试，然后接下来一周

241
00:13:00,980 --> 00:13:04,014
we're gonna talk about Swift and some other iOS things, and
我们会讲 Swift 和其他一些 iOS 的内容

242
00:13:04,083 --> 00:13:06,750
we're gonna do it all in with the Concentration app as
我们都会用翻牌游戏

243
00:13:06,819 --> 00:13:08,453
a little bit like our demo land.
把它作为做演示的地方

244
00:13:08,521 --> 00:13:10,454
I'll show you, talk to you about something, some slides,
我会讲解某些内容，给你看些幻灯片

245
00:13:10,523 --> 00:13:11,722
and then we'll go to Concentration.
然后我们到翻牌游戏里

246
00:13:11,791 --> 00:13:16,827
I'll show you how it actually looks. All right, here we are,
我给你看看实际上是什么样的。好，我们到 Xcode 里

247
00:13:16,896 --> 00:13:21,265
back exactly where we were at the end of Monday. We've got
回到我们星期一下课的时候所在的地方。我们有

248
00:13:21,333 --> 00:13:24,301
our view controller here. We're all ready along the way
我们的视图控制器，我们已经在运用

249
00:13:24,370 --> 00:13:29,339
of MVC. Right here, in this story board, that's our V,
MVC 的路上了。这里我们的 storyboard 就是 V(iew)

250
00:13:29,408 --> 00:13:33,644
our view, and right here, this is our C our controller. Okay,
我们的视图。然后这里就是我们的 C(ontroller)，控制器

251
00:13:33,713 --> 00:13:35,879
so this is our controller, and this is our view.
所以这是我们的控制器，这是我们的视图

252
00:13:35,948 --> 00:13:40,084
So we need the M. So let's go make the M right now. So
我们需要 M(odel)，那我们现在就创建这个模型

253
00:13:40,153 --> 00:13:44,689
how do we make a new class or whatever in Xcode.
那在 Xcode 里我们如何创建一个新的类呢？

254
00:13:44,757 --> 00:13:48,893
We go to file > new > file. That's how you create a new
我们的菜单栏的 File > New > File...，这就是

255
00:13:48,961 --> 00:13:51,596
Swift file, or whatever, and when you do that, it's gonna
我们创建类似于新 Swift 文件的方法。当你点击之后，他会

256
00:13:51,664 --> 00:13:55,232
offer you a lot of different kinds of iOS files you want,
提供很多种你可能想要的，有关 iOS 的不同种类的文件

257
00:13:55,301 --> 00:13:57,869
but really these are the two that are most interesting.
但我们最关心的是这两个

258
00:13:57,938 --> 00:14:00,405
This is if you wanna create a subclass of
这个是如果你想创建一个子类

259
00:14:00,473 --> 00:14:03,674
a Coco Touch class, of an iOS class, like a subclass of
继承自 iOS 的 Cocoa Touch 框架的某个类

260
00:14:03,743 --> 00:14:06,077
another view controller or something like that.
比如创建一个继承 UIViewController 的子类

261
00:14:06,145 --> 00:14:09,313
But here we're talking about the model, non-UI, so
但我们现在是要模型，和 UI 无关，所以

262
00:14:09,382 --> 00:14:14,051
we're going to pick a blank, totally blank Swift file.
我们选择空白的，完全空的 Swift 文件

263
00:14:14,120 --> 00:14:18,789
This is asking the name, we always name the files that we
这里问文件的名字，我们总是把文件

264
00:14:18,858 --> 00:14:21,959
are creating in Swift. We name it after the most
创建的 Swift 文件，依据

265
00:14:22,028 --> 00:14:25,797
important class that's gonna be in that file. Now I'm gonna
文件里最重要的类命名。那我要

266
00:14:25,865 --> 00:14:28,866
call my model, my main model class, Concentration,
把我的模型，主要的模型类叫做 Concentration

267
00:14:28,935 --> 00:14:31,536
because it is the thing that implements the game
因为模型实现了游戏

268
00:14:31,604 --> 00:14:34,939
Concentration, so it deserves the name Concentration, so
翻牌，所以应该用游戏英文名 Concentration 命名

269
00:14:35,007 --> 00:14:38,275
that's what I'm gonna call it. By the way, I'm not gonna
所以这就是我给它的名字。顺便一提，我不会

270
00:14:38,344 --> 00:14:41,512
put it, you see this group, this is the top level project,
把它，你看这里有个 Group，现在是项目的最顶层

271
00:14:41,581 --> 00:14:44,382
you really wanna put it in the folder one level down.
你应该把它放在下一层的文件夹里

272
00:14:44,451 --> 00:14:46,717
It's the same folder where your view controller it's
和你的视图控制器放在同一个文件夹里

273
00:14:46,786 --> 00:14:48,653
a better place to put it than at the top level.
放那里比放项目最顶层要好

274
00:14:48,722 --> 00:14:50,254
It'll work if you put it in the top level, but
放在最顶层也是可以的

275
00:14:50,323 --> 00:14:53,324
it just looks nicer to put it down here. All right so
但是放在这下面会好看些。好

276
00:14:53,392 --> 00:14:56,393
I'm gonna create this Swift file, it creates it for us.
我点 Create 创建这个 Swift 文件，Xcode 已经创建好了

277
00:14:56,462 --> 00:14:59,229
To make it full screen here. Notice that all it says is
我把它全屏显示。注意这里唯一的代码是

278
00:14:59,298 --> 00:15:04,001
import Foundation. Not import UI kit. This is not a UI file.
import Foundation 而不是 UIKit，因为只是和 UI 无关的文件

279
00:15:04,070 --> 00:15:06,503
This is a model totally UI independent.
这个模型是和 UI 不沾边的

280
00:15:06,572 --> 00:15:07,871
So I'm gonna make my class here.
我要在这里定义我的类

281
00:15:07,940 --> 00:15:17,014
I'm gonna call it Concentration. Concentration.
我要把它叫做 Concentration

282
00:15:17,083 --> 00:15:21,052
Okay, is my class, and when ever I build a new class,
好，这是我的类。每当我定义了一个新的类

283
00:15:21,120 --> 00:15:24,855
I always wanna think about what its public API is.
我总是要考虑它的 public API，公开的应用程序接口

284
00:15:24,924 --> 00:15:28,126
How many people know what the phrase API mean?
有多少人知道 API 是什么意思？

285
00:15:28,194 --> 00:15:30,895
Well, almost nobody, okay. So, API stands for
好吧，基本没人知道。所以 API 是

286
00:15:30,964 --> 00:15:34,098
Application Programing Interface. It's just a list of
Application Programing Interface 的缩写，其实就是

287
00:15:34,166 --> 00:15:37,668
all the methods and instance variables in that class and
这个类所有的方法和实例变量的列表

288
00:15:37,736 --> 00:15:41,239
the public API is all the instance variables and methods
而公有的应用程序接口就是所有实例变量和方法

289
00:15:41,307 --> 00:15:44,975
that you're going to allow other classes to call. So it's
你允许其他类访问的那部分。所以

290
00:15:45,044 --> 00:15:47,912
basically how you use this class, and next week we'll
基本上就是你能如何使用这个类，然后下一周我们

291
00:15:47,981 --> 00:15:50,648
talk about how you actually make things private and
会讲如何让这些接口变为私有（private）的

292
00:15:50,717 --> 00:15:53,918
public, but today we're not going to worry about that, but
或是公开（public）的，但我们今天不操心这个

293
00:15:53,986 --> 00:15:56,420
I'm going to basically design my public API.
但我会先设计我的公开的应用程序接口

294
00:15:56,489 --> 00:16:01,159
Now why, when I kind of design my vars and funcs right off
那为什么我要在一开始就设计我的变量和方法呢？

295
00:16:01,227 --> 00:16:04,461
the bat here, And the reason is because to do that I have
原因是要能够设计 API 的话，我需要

296
00:16:04,530 --> 00:16:07,965
to get the essentials of what is it that this thing does and
理解这个东西本质上能做什么，以及

297
00:16:08,034 --> 00:16:09,633
how are people gonna use it. And
人们如何使用它。这样

298
00:16:09,702 --> 00:16:12,703
that makes me think clearly as I go in to my design here. So
我设计的时候就能思路清晰。因此

299
00:16:12,772 --> 00:16:13,738
I recommend doing this for
我建议你这样做

300
00:16:13,806 --> 00:16:17,741
any class that you design. So a concentration game.
在设计任何类的时候都这样。那对于翻牌游戏

301
00:16:17,810 --> 00:16:20,845
Remember, we had it up here? What are the essentials of it?
就是我们摆在这里的这个，它的本质是什么？

302
00:16:20,914 --> 00:16:25,049
Well, one essential is it has some cards. That card,
它最基本的就是有一些卡片

303
00:16:25,117 --> 00:16:28,986
those cards are arrays of cards or something,
那些卡片可以用一个卡片的数组来表示

304
00:16:29,055 --> 00:16:34,024
not quite sure what, some kind of arrays of card. So,
我还不是很确定，某种类似于存放卡片的数组

305
00:16:34,093 --> 00:16:36,093
that's a fundamental part of the Concentration game for
这就是翻牌游戏的基础

306
00:16:36,162 --> 00:16:40,564
sure. What about, what can you do in the Concentration game?
那么你可以在翻牌游戏里做什么？

307
00:16:40,633 --> 00:16:43,834
The only thing that you're allowed to do as a user is
玩家唯一能做的一件事就是

308
00:16:43,902 --> 00:16:46,337
flip the cards over, right, choose cards. That's all you
把一张卡翻过来，对吧？选择一张卡翻面

309
00:16:46,405 --> 00:16:48,706
can really choose cards. All the matching and
你能做的就是翻牌。对于配对

310
00:16:48,775 --> 00:16:51,041
all that stuff is kind of internal implementation of
这些都是我们内部的实现

311
00:16:51,110 --> 00:16:54,178
the Concentration game. From user's perspective,
翻牌游戏自己处理的。对于玩家而言

312
00:16:54,246 --> 00:16:56,780
you're just touching on it. So I'm gonna need some func
你只是点一张卡片。所以我需要某个方法

313
00:16:56,849 --> 00:17:00,050
that let's me choose a card. Okay, and
能让我选择一张卡片

314
00:17:00,119 --> 00:17:03,421
the argument to this could be either a card, one of whatever
这个方法的参数，要么是张卡片，某个

315
00:17:03,489 --> 00:17:06,557
this thing is which we're gonna define in a second, but
这个类的实例，Card 这个类我们等会儿定义

316
00:17:06,626 --> 00:17:09,627
I'm actually gonna make it be a little more flexible,
但我实际会让它更灵活

317
00:17:09,696 --> 00:17:13,231
I'm gonna make it be the index into this array. So when you
我接受这张卡在这个数组里的索引

318
00:17:13,299 --> 00:17:15,766
choose a card, I'm gonna let you choose it by index
所以当你选择一张卡，我会让你选择它的索引

319
00:17:15,834 --> 00:17:18,336
and that's just to be a little more flexible to different
这样可以更灵活地让不同的

320
00:17:18,405 --> 00:17:20,437
kinds of UI's that might want to do this.
用户界面来实现这个功能

321
00:17:20,506 --> 00:17:23,240
They might be index based. It's really not that big of
这些 UI 可能是基于索引的。这其实影响不大

322
00:17:23,309 --> 00:17:25,809
a deal cuz you could always just look up the index in this
因为你总是可以通过索引查找

323
00:17:25,878 --> 00:17:26,711
array all the time.
数组里的元素

324
00:17:26,779 --> 00:17:30,648
But it's a little easier to subscript an array and
但确实把索引作为下标（subscript）访问数组元素

325
00:17:30,717 --> 00:17:32,183
find something than to go the other way around,
比在数组中找到某个元素要简单点

326
00:17:32,251 --> 00:17:36,787
do index of like we did last time. So that's it actually.
要比用上次的 index(of:) 简单。好了，这就完了

327
00:17:36,855 --> 00:17:40,157
This is all, this is the entirety of the public API
这就是所有的，我们全部公开的应用程序接口

328
00:17:40,226 --> 00:17:42,659
of my Concentration game. Could not be simpler.
我的翻牌游戏就这样，不能再简单了

329
00:17:42,728 --> 00:17:45,763
Now the only thing here is we gotta define Mr.Card. So
但现在我们要做的就是定义 Card 这个代表卡片的类

330
00:17:45,832 --> 00:17:51,302
we're gonna go file>new>file and create another Swift file.
我们还是 File > New > File... 创建另一个 Swift 文件
 
331
00:17:51,371 --> 00:17:54,205
This one I'm gonna call card. Okay,
这个我把它叫做 Card

332
00:17:54,273 --> 00:17:56,340
put it in the same place as everything else there.
把它和其他的放在一起

333
00:17:58,111 --> 00:18:00,577
All right, again, this is not a UI thing.
好，同样这不是 UI 相关的

334
00:18:00,646 --> 00:18:03,181
This is part of my model. So I have two things in my model.
这也是我模型的一部分。所以我的模型有两个部分

335
00:18:03,249 --> 00:18:05,749
The Concentration game and this card. What's really
一个是翻牌游戏，一个是卡牌

336
00:18:05,818 --> 00:18:10,154
interesting here is I'm going to make card to be a struct.
很有趣的是我要用 struct 关键字定义 Card

337
00:18:11,824 --> 00:18:16,894
Not a class. Now what's the difference
而不是 class。那有什么区别？

338
00:18:16,963 --> 00:18:20,564
between a struct and a class? Let's go ahead and
struct 和 class 有什么区别？让我们

339
00:18:20,633 --> 00:18:22,999
get the concentration up here in the same time.
把 Concentration 类也同时显示出来

340
00:18:23,068 --> 00:18:28,872
Can use my manual thing here. We've got card on the left and
我能够用 Manual 手动选择它。我们 Card 在左边

341
00:18:28,941 --> 00:18:32,543
structure on the right. One's a class, one's a struct. Now
然后 Concentration 在右边。右边的是 class，左边是 struct

342
00:18:32,612 --> 00:18:35,379
in a lot of other languages like C, a struct is just kinda
在很多像 C 语言一类的语言，struct，结构体

343
00:18:35,447 --> 00:18:39,016
this little thing that holds a little bit of data.
就是某种存储少量数据的类型

344
00:18:39,084 --> 00:18:41,552
It's nothing really that big a deal, but in Swift,
不是什么重要的东西。但 Swift 里

345
00:18:41,621 --> 00:18:44,322
structs and classes are almost exactly the same.
结构体和类基本是一样的

346
00:18:44,390 --> 00:18:48,291
They have methods, they have vars, very very similar. So
他们都可以有方法，有变量，非常相似

347
00:18:48,360 --> 00:18:49,860
what is the difference between the two?
那这两个之间的区别是什么？

348
00:18:49,929 --> 00:18:52,529
There's two major differences. There's some minor
主要有两个区别。有些小的

349
00:18:52,598 --> 00:18:54,231
differences we'll run across as we going over this, but
区别我们等会儿会过一遍

350
00:18:54,300 --> 00:18:56,400
there's two major differences between a struct and a class.
但是结构体和类两个最主要的区别

351
00:18:56,469 --> 00:18:59,770
This is very important to understand this.
理解这个是非常总要的

352
00:18:59,839 --> 00:19:02,606
Number one, struct, no inheritance.
第一，结构体没有继承

353
00:19:02,675 --> 00:19:05,042
So you have no inheritance in struct that makes structs
所以结构体不能继承。这让结构体

354
00:19:05,111 --> 00:19:07,211
a little simpler. Because if you have inheritance, you have
稍微简单了些。因为如果有继承

355
00:19:07,280 --> 00:19:09,212
to kind of worry about all the things you're inheriting and
你必须要考虑继承的那些东西

356
00:19:09,281 --> 00:19:11,848
what that might mean for you. The struct has no inheritance
考虑那对你来说意味着什么。结构体没有继承

357
00:19:11,917 --> 00:19:15,453
so it's a little simpler than a class. Number two, and
所以它比类稍微简单些。第二

358
00:19:15,521 --> 00:19:19,956
the most important difference, is that structs are value
也是最重要的区别，结构体是值类型

359
00:19:20,025 --> 00:19:24,061
types and classes are reference types.
而类是引用类型

360
00:19:24,129 --> 00:19:27,097
What does that mean? A value type,
那是什么意思？值类型

361
00:19:27,166 --> 00:19:30,267
when you pass it as an argument, put it in an array,
当你把它作为参数传入函数，把它放进数组

362
00:19:30,336 --> 00:19:33,938
even assign it to another variable, it gets copied.
甚至把它赋值给另一个变量，他都会被拷贝

363
00:19:35,441 --> 00:19:38,042
This is very important to understand. It gets copied.
理解这个是非常重要的。他会被拷贝

364
00:19:38,111 --> 00:19:40,210
And why is it so important that you understand this?
为什么你理解这个是非常重要的呢？

365
00:19:40,279 --> 00:19:42,179
Why don't you just avoid structs?
那你为什么不干脆避免使用结构体呢？

366
00:19:42,248 --> 00:19:44,114
Because you can't avoid structs in iOS.
因为你开发 iOS 是没法避免结构体的

367
00:19:44,183 --> 00:19:48,218
Arrays are structs, ints are structs, strings are structs,
数组是结构体，Int 整数是结构体，String 字符串是结构体

368
00:19:48,287 --> 00:19:50,921
dictionaries are structs, these are all structs.
Dictionary 字典是结构体，这些都是结构体

369
00:19:50,990 --> 00:19:52,490
When you pass them around in your code,
当你把他们在代码之间传递的时候

370
00:19:52,558 --> 00:19:54,625
they're getting constantly copied.
他们总是会被复制

371
00:19:54,694 --> 00:19:56,560
Now you might be kinda like, whoa wait a second,
那你现在可能会想，等等

372
00:19:56,629 --> 00:20:00,097
that is gonna be incredibly inefficient. No, because Swift
那会非常低效率。并不会，因为 Swift

373
00:20:00,165 --> 00:20:03,133
is super smart about when it passes these things around.
非常聪明，在把这些结构体四处传递的时候

374
00:20:03,202 --> 00:20:05,735
It doesn't copy all the bits of all the things of
它不会把所有这些的每个比特都复制

375
00:20:05,804 --> 00:20:08,872
the array when you pass it. It passes it in a way so that it
当你把数组传入的时候并不会这样。它传递的方法是

376
00:20:08,941 --> 00:20:11,609
only has to make copies, actual copies, when someone
只会在需要实际进行拷贝，也就是有人

377
00:20:11,677 --> 00:20:15,413
modifies it. That's called a copy-on-write semantics, and
修改了它的值才拷贝。这叫做 Copy-On-Write，写时复制

378
00:20:15,481 --> 00:20:17,982
that's the way Swift implements these value types.
这是 Swift 实现这些值类型的方法

379
00:20:18,050 --> 00:20:21,685
So structs are value types. Classes are reference types.
所以结构体是值类型，类是引用类型

380
00:20:21,754 --> 00:20:22,886
What's a reference type?
那什么是引用类型？

381
00:20:22,955 --> 00:20:25,156
That's what you're used to in other languages.
那是你在其他语言里熟悉的

382
00:20:25,224 --> 00:20:28,325
The thing lives in the heap. You got pointers to it. When
他们被存储在堆（heap）中，你保留指向它的指针

383
00:20:28,393 --> 00:20:31,028
you pass it around, you're not passing the thing around.
当你传递它的时候，你不会把对象四处传递

384
00:20:31,097 --> 00:20:32,329
You're just passing pointers to it.
你传递的是那个指针

385
00:20:32,398 --> 00:20:35,299
And so you might have a whole bunch of code that
所以你可能有很多代码

386
00:20:35,368 --> 00:20:38,001
has pointers to the same object. So
都拥有指向统一个对象的指针

387
00:20:38,070 --> 00:20:39,503
you see the difference there?
你看出区别了吗？

388
00:20:39,572 --> 00:20:42,373
So, structs are gonna take some getting used to because
确实要花些时间才能适应结构体

389
00:20:42,442 --> 00:20:43,908
you're not used to when you pass things,
因为你还不适应，在传递的时候

390
00:20:43,977 --> 00:20:46,377
it makes a copy. But you're going to see
他会拷贝这种机制。但你会看到

391
00:20:46,445 --> 00:20:49,613
it provides an awesome semantic that you can really
它提供的这种很好的机制，你其实可以

392
00:20:49,682 --> 00:20:52,249
use to your advantage. We're even gonna see that here
让它为你服务。我们甚至能够在这里看到

393
00:20:52,318 --> 00:20:55,586
in a small way in our example, but you'll definitely start
在这个程序里它的体现。但写时复制，你肯定会

394
00:20:55,655 --> 00:20:57,721
seeing it when you start using arrays and dictionaries and,
在开始使用数组和字典的时候看到

395
00:20:57,790 --> 00:21:02,226
such, stuff like that. Okay, structs, card here,
或者使用类似的东西的时候。好，Card 结构体

396
00:21:02,294 --> 00:21:03,894
what does a card need?
它需要什么？

397
00:21:03,962 --> 00:21:06,530
Well same thing, let's think about its essentials.
同样的，让我们来考虑他的本质是什么

398
00:21:06,599 --> 00:21:10,100
Certainly, a card can either be face up or not, so and
肯定有记录一张卡是否是面朝上的

399
00:21:10,169 --> 00:21:12,669
it probably always starts face down, let's say.
多半不是，我们决定开始的时候是面朝下的

400
00:21:12,738 --> 00:21:17,808
A card can be matched or not, probably starts out definitely

401
00:21:17,876 --> 00:21:21,545
unmatched. You know a card also needs a unique identity.

402
00:21:21,614 --> 00:21:23,581
Because we're playing a matching game and if we can't

403
00:21:23,649 --> 00:21:26,083
tell the identity of the card, we can't match it against

404
00:21:26,151 --> 00:21:29,286
another card. So we need some kind of identifier or

405
00:21:29,355 --> 00:21:31,321
something, which really could be any type.

406
00:21:31,390 --> 00:21:32,990
It could be a string or whatever. I'm gonna make

407
00:21:33,059 --> 00:21:36,993
an Int because it's really easy to make a unique Int.

408
00:21:37,062 --> 00:21:38,662
So, we definitely need that. Now,

409
00:21:38,731 --> 00:21:40,097
some of you might thinking, oh,

410
00:21:40,166 --> 00:21:44,134
okay a card also needs the emoji that's on it.

411
00:21:44,203 --> 00:21:47,838
Like the pumpkin or the ghost. And very importantly,

412
00:21:47,907 --> 00:21:53,343
no it doesn't. This card is UI independent.

413
00:21:53,412 --> 00:21:56,714
So there's no way it can have emojis or jpeg images or

414
00:21:56,782 --> 00:21:59,617
anything like that, that's all how you display the cards.

415
00:21:59,685 --> 00:22:02,886
This is just how the cards behave, how the game works. So

416
00:22:02,955 --> 00:22:05,722
you would never have an emoji in here, in this model. We're

417
00:22:05,791 --> 00:22:09,226
in the model here not the UI. Very important to understand.

418
00:22:10,862 --> 00:22:15,966
All right, so now we've got basically all of our API and

419
00:22:16,035 --> 00:22:18,636
our model here. Let's get rid of some these errors. You see

420
00:22:18,704 --> 00:22:21,371
that we still have this error class concentration has no

421
00:22:21,440 --> 00:22:23,740
initializers, a very common error that we're used to.

422
00:22:23,809 --> 00:22:27,144
That's because this var is never initialized, so

423
00:22:27,213 --> 00:22:30,514
how do we create an array of cards, okay?

424
00:22:30,582 --> 00:22:33,483
So this is now you're learning how to create an instance

425
00:22:33,552 --> 00:22:35,919
of a struct or of a class. It's exactly the same.

426
00:22:35,988 --> 00:22:39,456
And the way we do that is I'm just gonna say equals

427
00:22:39,525 --> 00:22:41,759
open parentheses, close parentheses.

428
00:22:41,827 --> 00:22:45,229
So this is just a type. It could be int or string.

429
00:22:45,297 --> 00:22:47,865
It happens to be an array of cards. And I'm just putting

430
00:22:47,933 --> 00:22:50,133
open parentheses, close parentheses after it. And

431
00:22:50,202 --> 00:22:53,904
I could actually be putting various arguments in here. And

432
00:22:53,973 --> 00:22:56,674
these correspond to those in ints I was telling you

433
00:22:56,742 --> 00:22:59,410
about. Remember last time, I said class could have

434
00:22:59,478 --> 00:23:01,578
an initializer, it's a special method called in it,

435
00:23:01,647 --> 00:23:03,446
it can have whatever arguments you want.

436
00:23:03,515 --> 00:23:08,084
You could have multiple in its. Array has an in it with

437
00:23:08,153 --> 00:23:11,855
no arguments and what it does is it creates an empty array.

438
00:23:11,924 --> 00:23:14,324
So the array exists, but there's no cards in it.

439
00:23:14,393 --> 00:23:17,427
There's nothing in it. There are other, and you can go look

440
00:23:17,496 --> 00:23:19,863
in the documentation, for other inlets that array has.

441
00:23:19,931 --> 00:23:23,434
It has an it, for example, let's you reserve capacity for

442
00:23:23,502 --> 00:23:25,435
a certain amount for performance reasons if you're

443
00:23:25,504 --> 00:23:27,871
pretty sure you know how big there's going to be array.

444
00:23:27,940 --> 00:23:30,173
You can create an array from another array and

445
00:23:30,242 --> 00:23:32,409
it'll copy over the items from that other array,

446
00:23:32,478 --> 00:23:35,645
so there are other in its, but the most common array in it

447
00:23:35,714 --> 00:23:38,382
is this one where you just do nothing.

448
00:23:38,450 --> 00:23:42,719
Now by the way, we're using this kind of easier to

449
00:23:42,788 --> 00:23:46,456
understand syntax, but we would almost certainly use

450
00:23:46,525 --> 00:23:51,861
this syntax. Array of Card. So I showed you last time.

451
00:23:51,930 --> 00:23:55,032
So I've got an empty array of cards to work with right here.

452
00:23:55,101 --> 00:23:58,001
I've got no warnings. So now, it's time to go

453
00:23:58,070 --> 00:24:02,406
back to our controller and try to start using this model. So

454
00:24:02,474 --> 00:24:04,474
were doing NBC were going back to our control. So

455
00:24:04,543 --> 00:24:08,345
I'm gonna back over here. I'm gonna go to my ViewController.

456
00:24:08,413 --> 00:24:10,280
let's have the Concentration on at the same time here. So

457
00:24:10,281 --> 00:24:12,148
Actually, let's go,

458
00:24:12,218 --> 00:24:13,250
we've got Concentration,

459
00:24:13,318 --> 00:24:16,220
I'll make it small, there it is, and our ViewController,

460
00:24:16,288 --> 00:24:20,557
so how am I gonna use my model in this controller? Well,

461
00:24:20,625 --> 00:24:23,927
the first thing I wanna do is make that big green arrow,

462
00:24:23,996 --> 00:24:26,697
the green arrow that points from my controller to my

463
00:24:26,766 --> 00:24:29,700
model. And I'm gonna do that by creating a var

464
00:24:29,768 --> 00:24:32,969
in my controller, and call it game. And it's gonna be of

465
00:24:33,038 --> 00:24:37,841
type Concentration. There's my big green arrow. I can send

466
00:24:37,910 --> 00:24:41,779
any messages I want to game, like, I can get at its cards.

467
00:24:41,847 --> 00:24:45,182
I can choose a card, whatever. and I'm ready to go.

468
00:24:45,250 --> 00:24:48,051
Now, look at the error I get, our favorite error,

469
00:24:48,120 --> 00:24:50,553
Class ViewController has no initializers, because this

470
00:24:50,622 --> 00:24:54,158
is not initialized. How are we gonna initialize this?

471
00:24:54,226 --> 00:24:56,893
Let's see, we wanna do something similar to what we

472
00:24:56,962 --> 00:24:59,563
did with this array over here. Let's try that, let's do

473
00:24:59,632 --> 00:25:04,200
Concentration,this is probably not gonna work, right?

474
00:25:04,269 --> 00:25:06,703
Because we didn't create an init with no arguments for

475
00:25:06,772 --> 00:25:09,906
Concentration. But it did work!

476
00:25:09,975 --> 00:25:14,878
How could this possibly work? The answer here is classes,

477
00:25:14,947 --> 00:25:19,683
and Concentration is a class, get a free init with no

478
00:25:19,751 --> 00:25:23,253
arguments as long as all of their vars are initialized.

479
00:25:23,322 --> 00:25:26,122
And this only has one var, it's initialized, so

480
00:25:26,191 --> 00:25:30,694
Concentration got a free init. We're initialized.

481
00:25:30,763 --> 00:25:33,797
We don't actually need this type. Remember why?

482
00:25:33,865 --> 00:25:36,600
Type inference, obviously Swift can figure out from that

483
00:25:36,668 --> 00:25:39,202
line of code the game is of type Concentration, we don't

484
00:25:39,271 --> 00:25:42,739
need to put that in there. But this was fun and nice that we

485
00:25:42,808 --> 00:25:46,142
got this free initializer, but actually, it's no good.

486
00:25:46,211 --> 00:25:49,245
It's not good enough. Because when we create a Concentration

487
00:25:49,314 --> 00:25:52,182
game, we gotta think how many cards there are. Because

488
00:25:52,251 --> 00:25:54,685
the Concentration game has to kinda load up this array over

489
00:25:54,753 --> 00:25:56,820
here with all the cards that it's gonna use,

490
00:25:56,888 --> 00:25:59,556
and we can't assume that a Concentration game only has 12

491
00:25:59,625 --> 00:26:02,559
cards like we had on the board. Or only has four cards,

492
00:26:02,628 --> 00:26:07,231
like our current UI here has. We actually need to create our

493
00:26:07,299 --> 00:26:11,034
own init. So let's go, again, make some more space over

494
00:26:11,103 --> 00:26:15,238
here. And add an init to our Concentration class.

495
00:26:15,307 --> 00:26:18,374
Init. Now again, we get to have any arguments we want.

496
00:26:18,443 --> 00:26:20,944
And what we need to create our game is we need to know

497
00:26:21,013 --> 00:26:25,182
the number of pairs of cards. And that's gonna be an Int.

498
00:26:27,186 --> 00:26:29,119
So this is the initializer that people are gonna

499
00:26:29,187 --> 00:26:31,321
have to use to create a Concentration game.

500
00:26:31,390 --> 00:26:35,792
Cuz we need this. So how are we gonna implement this init?

501
00:26:35,861 --> 00:26:39,996
We need to create this many pairs of cards and

502
00:26:40,065 --> 00:26:44,901
put them in here. Let's try and create one card.

503
00:26:44,970 --> 00:26:48,538
Let card =, maybe we'll get lucky and

504
00:26:48,607 --> 00:26:51,675
we can just say card. We got, that worked for

505
00:26:51,743 --> 00:26:56,212
Concentration. Didn't work. Why didn't that work?

506
00:26:56,281 --> 00:27:00,083
Because if you look over here to our card.

507
00:27:00,152 --> 00:27:04,888
Let's bring up Mr. Card here. The card,

508
00:27:04,956 --> 00:27:10,227
it has something that has to be initialized there.

509
00:27:10,296 --> 00:27:15,198
Card is a struct. Now, structs get a free initializer

510
00:27:15,267 --> 00:27:17,367
as well, but it's different than a class.

511
00:27:17,436 --> 00:27:19,803
So this is another difference between structs and classes.

512
00:27:19,871 --> 00:27:23,807
Struct, the free initializer they get, initializes all of

513
00:27:23,876 --> 00:27:26,376
their vars, even if they're already pre-initialized,

514
00:27:26,445 --> 00:27:28,712
like isFaceUp and isMatched. Watch this, okay,

515
00:27:28,780 --> 00:27:31,548
I'm gonna just type card. Open parenthesis,

516
00:27:31,617 --> 00:27:34,884
I'm gonna let Xcode show me the initializer, and

517
00:27:34,953 --> 00:27:38,955
you can see that it just initializes every single one.

518
00:27:39,024 --> 00:27:42,192
So I could do isFaceUp false, isMatched false,

519
00:27:42,261 --> 00:27:45,796
the identifier, I guess I'm gonna have to make up some

520
00:27:45,864 --> 00:27:48,165
identifier for this thing to do it.

521
00:27:48,233 --> 00:27:51,034
So I could initialize a card like that, cuz I get a free

522
00:27:51,103 --> 00:27:54,504
initializer. Classes never get this kind of free initializer.

523
00:27:54,573 --> 00:27:56,173
They don't get the free initializer where they,

524
00:27:56,241 --> 00:27:58,508
you can initialize all their vars.

525
00:27:58,576 --> 00:28:02,279
That's purely a struct thing. But this is bogus, because

526
00:28:02,348 --> 00:28:05,181
these are, start out false, so why, when I'm initializing,

527
00:28:05,250 --> 00:28:08,018
do I have to say again they're false? If I want to get rid of

528
00:28:08,087 --> 00:28:10,587
those, and to get rid of those, I have to add

529
00:28:10,656 --> 00:28:13,523
an initializer here. So I'm gonna have an initializer that

530
00:28:13,592 --> 00:28:17,995
just takes the identifier, which is an Int.

531
00:28:18,063 --> 00:28:22,366
And then I wanna set this identifier right here equal to

532
00:28:22,434 --> 00:28:28,071
this identifier right here. We've

533
00:28:28,140 --> 00:28:31,208
got a couple of problems with that, with trying to do that.

534
00:28:31,276 --> 00:28:34,177
One is this certainly can't be right. Identifier equals

535
00:28:34,246 --> 00:28:38,548
identifier? That, that's just weird. One thing also notice

536
00:28:38,617 --> 00:28:42,319
that in both of my inits, I didn't do an external name and

537
00:28:42,387 --> 00:28:44,020
an internal name. You notice that?

538
00:28:44,089 --> 00:28:46,389
I only did one, which means both the external name and

539
00:28:46,458 --> 00:28:49,226
the internal name is the same. So one thing I could do to fix

540
00:28:49,295 --> 00:28:52,529
that is make the internal name be different, like i.

541
00:28:52,598 --> 00:28:54,865
And then I could say identifier = i.

542
00:28:54,933 --> 00:28:57,534
You see? This is the external name,

543
00:28:57,603 --> 00:29:00,103
I'm using it here when I call this init.

544
00:29:00,172 --> 00:29:03,407
And this is the internal name, which I'm using inside here.

545
00:29:03,475 --> 00:29:06,543
And now it knows that this identifier means that one. But

546
00:29:06,612 --> 00:29:08,545
you know what? This is kinda gross. First of all,

547
00:29:08,613 --> 00:29:12,916
I hate variable names like i. i is a bad variable name.

548
00:29:12,984 --> 00:29:15,518
I just don't wanna have it here. But I can't really think

549
00:29:15,587 --> 00:29:19,089
of another one here that's any better than identifier.

550
00:29:19,157 --> 00:29:20,957
That's, identifier is a good name there. So

551
00:29:21,026 --> 00:29:23,560
I actually want it to be same internal name and

552
00:29:23,628 --> 00:29:28,431
external name. Now, inits are the one method that

553
00:29:28,500 --> 00:29:33,336
usually has the same internal name and external name. Most

554
00:29:33,405 --> 00:29:36,873
functions don't, but inits tend to. They don't have to,

555
00:29:36,942 --> 00:29:41,144
but they tend to. So, now I'm back to saying this, but

556
00:29:41,213 --> 00:29:43,613
it's not, I can't really distinguish between these two,

557
00:29:43,682 --> 00:29:46,183
so how can I distinguish between two, these two?

558
00:29:46,251 --> 00:29:51,220
This is the parameter. This is my identifier on myself.

559
00:29:51,289 --> 00:29:58,028
Well, I can say, self. So, self., means my identifier.

560
00:29:58,096 --> 00:30:01,965
This card's identifier. So now it knows we want this one,

561
00:30:02,034 --> 00:30:06,169
and so this one is this one. That's kinda cool.

562
00:30:06,237 --> 00:30:11,040
We got out of having that going on. All right, so

563
00:30:11,109 --> 00:30:12,709
let's go back over here again.

564
00:30:12,777 --> 00:30:15,979
We're able to create one card, great, worked good.

565
00:30:16,048 --> 00:30:19,316
But we have to specify the identifier for the card. So

566
00:30:19,384 --> 00:30:21,551
this really doesn't matter what the identifier is,

567
00:30:21,620 --> 00:30:24,621
as long as it's unique. So I'm gonna create a for loop. So

568
00:30:24,690 --> 00:30:26,723
pay attention, here's how you create a for loop in Swift.

569
00:30:26,792 --> 00:30:30,159
It's a little different than other languages. It starts out

570
00:30:30,228 --> 00:30:34,197
the same. For identifier, this is just for some variable. But

571
00:30:34,266 --> 00:30:38,902
you don't say equals zero, less than 20, i plus plus,

572
00:30:38,971 --> 00:30:42,506
we don't do any of that. Instead we use the word, in,

573
00:30:42,574 --> 00:30:46,576
and then this right here can be anything in Swift that is

574
00:30:46,645 --> 00:30:50,880
a sequence. And a sequence in Swift means anything where you

575
00:30:50,949 --> 00:30:53,249
can start somewhere and go to the next one, go to next one,

576
00:30:53,318 --> 00:30:55,151
go to the next one, and that's what a for loop does.

577
00:30:55,220 --> 00:30:56,686
It starts somewhere, and it goes to the next one, and

578
00:30:56,755 --> 00:30:58,288
goes to the next one, goes to the next one. So

579
00:30:58,356 --> 00:31:01,558
what are some examples of sequences in Swift?

580
00:31:01,627 --> 00:31:04,995
Arrays? Okay, obviously array, you could start at the first

581
00:31:05,064 --> 00:31:06,596
element, and go to the next one, go to the next one,

582
00:31:06,665 --> 00:31:07,764
till you get to the end.

583
00:31:07,833 --> 00:31:11,801
String, a string is a sequence. First character,

584
00:31:11,870 --> 00:31:13,302
go to the next character, go to the next character,

585
00:31:13,371 --> 00:31:17,440
next character. The one I'm gonna use here is a really

586
00:31:17,509 --> 00:31:20,276
cool sequence called a countable range. So

587
00:31:20,345 --> 00:31:22,812
a countable range is a range, in other words, it has a start

588
00:31:22,881 --> 00:31:25,115
and an end, and it's countable. In other words,

589
00:31:25,184 --> 00:31:28,118
it knows how to count through it and go to the next space.

590
00:31:28,186 --> 00:31:31,054
And there's special syntax in Swift because it's so

591
00:31:31,123 --> 00:31:33,089
common to wanna make a countable range. And

592
00:31:33,158 --> 00:31:38,294
it goes like this. The start of the countable range,

593
00:31:38,363 --> 00:31:41,998
..<, which means from 0 up to and

594
00:31:42,067 --> 00:31:46,236
not including the number of pairs of cards.

595
00:31:48,673 --> 00:31:52,609
So this is a for loop that is going to go through,

596
00:31:52,677 --> 00:31:55,511
why is that not cutting? I didn't select it,

597
00:31:55,580 --> 00:31:59,215
I guess? Cut, there we go, paste. It's gonna go through

598
00:31:59,284 --> 00:32:02,552
the number of pairs of cards. Now, there's another kind of

599
00:32:02,621 --> 00:32:07,324
countable range creator here, which is .. Dot,

600
00:32:07,392 --> 00:32:11,594
that means zero to here, including this one.

601
00:32:11,663 --> 00:32:14,197
So, here, if I wanted to use that one, I would say one dot,

602
00:32:14,265 --> 00:32:18,100
dot, dot cuz I only want this many cards. So, that makes

603
00:32:18,169 --> 00:32:22,305
a countable range. In fact, if you look at this thing's type,

604
00:32:22,373 --> 00:32:26,476
it'll be countable range. Okay, so now I'm going through

605
00:32:26,544 --> 00:32:29,479
and creating a card here, but I need another card.

606
00:32:29,548 --> 00:32:33,983
So I could say matchingCard = the same thing, right?

607
00:32:34,052 --> 00:32:37,754
Create another card with the same identifier. Makes sense,

608
00:32:37,822 --> 00:32:40,323
right? Now I have two cards that match that I can add to

609
00:32:40,392 --> 00:32:41,691
my bunch of cards up here.

610
00:32:41,760 --> 00:32:42,992
I always need two cards that match,

611
00:32:43,061 --> 00:32:46,196
but you know what's amazing is I actually don't even need to

612
00:32:46,265 --> 00:32:50,934
do this right here. I can just do this,

613
00:32:53,071 --> 00:32:56,906
because when you assign a struct, which card is

614
00:32:56,975 --> 00:33:02,111
a struct, to another variable, it copies it. So

615
00:33:02,180 --> 00:33:05,748
matchingCard is a copy of card. Just by assigning it,

616
00:33:05,817 --> 00:33:10,353
it makes it a copy. Now I have a card and a copy of it. So

617
00:33:10,422 --> 00:33:12,455
I can say cards.append,

618
00:33:12,524 --> 00:33:17,293
that's how you add something to an array, append the card,

619
00:33:17,362 --> 00:33:22,265
and then cards.append the matching card, matchingCard.

620
00:33:22,333 --> 00:33:25,168
So now I've added these two matching cards to my array.

621
00:33:25,237 --> 00:33:27,837
And I'm going to do that number of pairs of cards

622
00:33:27,906 --> 00:33:30,073
times. I've got my cards,

623
00:33:30,141 --> 00:33:33,977
however I don't even need this matching card.

624
00:33:34,045 --> 00:33:37,747
I can get rid of that, and instead just say append(card).

625
00:33:37,816 --> 00:33:41,851
Because putting things in an array or taking them out also

626
00:33:41,919 --> 00:33:46,590
copies the card. There are actually three cards involved

627
00:33:46,658 --> 00:33:49,625
here. This one I create, the copy that gets put in here,

628
00:33:49,694 --> 00:33:53,363
and another different copy that gets put here. So

629
00:33:53,431 --> 00:33:56,132
understand that when you pass these structs around,

630
00:33:56,200 --> 00:33:57,901
you are copying them.

631
00:33:57,969 --> 00:34:01,338
Now later when we turn one of these cards face up,

632
00:34:01,407 --> 00:34:03,373
the copy will actually be a real copy and

633
00:34:03,442 --> 00:34:06,542
only one of them so it's not a pointer to the same card and

634
00:34:06,611 --> 00:34:09,779
memory, it's actually two different cards. By the way,

635
00:34:09,847 --> 00:34:12,748
another cool way we can do this different syntax is I can

636
00:34:12,817 --> 00:34:16,886
say cards, which is an array of cards,

637
00:34:16,955 --> 00:34:21,591
+= another array of cards, with those two cards.

638
00:34:23,562 --> 00:34:26,763
Plus equals works with arrays. You can add arrays together

639
00:34:26,831 --> 00:34:29,499
and this, putting this card in this array and

640
00:34:29,567 --> 00:34:33,069
this card in this array copies it. And then we put it in

641
00:34:33,138 --> 00:34:36,305
there, and in effect this array also gets copied

642
00:34:36,374 --> 00:34:41,310
cuz array is a struct. All right, so we got that,

643
00:34:41,379 --> 00:34:44,681
this is all going quite well. The only thing I don't really

644
00:34:44,750 --> 00:34:47,717
like about this is it doesn't really seem right to me that

645
00:34:47,786 --> 00:34:50,654
the concentration game has to pick the identifiers for

646
00:34:50,722 --> 00:34:53,456
the cards, because the concentration game does not

647
00:34:53,525 --> 00:34:55,191
care what the identifiers are.

648
00:34:55,260 --> 00:34:58,761
All it cares is that they're unique. So really,

649
00:34:58,830 --> 00:35:01,998
I don't wanna do this. I want to get this out of here, and

650
00:35:02,067 --> 00:35:06,636
have the card figure out its own unique identifier. There's

651
00:35:06,704 --> 00:35:09,739
no reason the card could just like pick 1 billion and 7.

652
00:35:09,807 --> 00:35:12,141
And that's its, as long as that's unique and

653
00:35:12,210 --> 00:35:14,978
it never gives out another card with 1 billion and 7,

654
00:35:15,046 --> 00:35:17,380
then it should be unique. That's what I do.

655
00:35:17,448 --> 00:35:21,150
I want this init to not have to take this identifier. But

656
00:35:21,219 --> 00:35:24,721
if this init over here doesn't take the identifier, then we

657
00:35:24,790 --> 00:35:28,691
gotta figure out how to create a unique identifier here. So

658
00:35:28,760 --> 00:35:31,227
how are we gonna do that? Well, I'm going to teach you

659
00:35:31,296 --> 00:35:34,163
another cool Swift thing, which is I'm going to create

660
00:35:34,232 --> 00:35:39,436
a special kind of method. It's a static method.

661
00:35:39,504 --> 00:35:43,907
It's a same syntax func but it has static before it, and

662
00:35:43,975 --> 00:35:48,745
it's going to get a unique identifier. It's gonna return

663
00:35:48,813 --> 00:35:52,015
an int that's gonna be unique. And every time I call it,

664
00:35:52,084 --> 00:35:54,517
it's gonna return me another unique identifier.

665
00:35:54,586 --> 00:35:56,853
It's just gonna return some unique identifier.

666
00:35:56,921 --> 00:35:59,989
We're gonna have to make it work. Now, what is a static

667
00:36:00,058 --> 00:36:03,526
function all about? A static function is a function,

668
00:36:03,595 --> 00:36:06,329
even though it's in the card class, you can't send it

669
00:36:06,397 --> 00:36:11,000
to a card. A card does not understand this message.

670
00:36:11,069 --> 00:36:14,938
What understands this message is the type card.

671
00:36:16,174 --> 00:36:18,908
You send it to the type itself.

672
00:36:18,977 --> 00:36:21,811
So you can think of it kind of like a global function,

673
00:36:21,880 --> 00:36:24,747
a utility function or something that's just tied to

674
00:36:24,816 --> 00:36:28,952
the type. Does it make sense? You don't send it to a card.

675
00:36:29,020 --> 00:36:31,154
You can't ask a card for a unique identifier.

676
00:36:31,222 --> 00:36:34,891
You ask the card type. So, and that's what static means.

677
00:36:34,960 --> 00:36:38,361
So here when I want to call this function,

678
00:36:38,430 --> 00:36:43,066
I send it to the type card.getUniqueIdentifier.

679
00:36:43,134 --> 00:36:46,802
That's getting it from the card type. Now how am I gonna

680
00:36:46,871 --> 00:36:49,272
implement this get unique identifier? Well,

681
00:36:49,340 --> 00:36:53,310
I'm gonna have a static var, cuz you can have those too.

682
00:36:53,378 --> 00:36:56,179
So that's a variable that's stored with the type,

683
00:36:56,248 --> 00:36:59,549
not with each individual card. These are scored with

684
00:36:59,618 --> 00:37:01,517
each individual card, this is stored with the type.

685
00:37:01,586 --> 00:37:05,088
And I'm gonna call this my identifierFactory,

686
00:37:05,157 --> 00:37:09,158
I'm just gonna start out with = 0. And then in here,

687
00:37:09,227 --> 00:37:13,730
what I'm going to say is Card.identifierFactory += 1 to

688
00:37:13,798 --> 00:37:17,266
make it a new unique identifier. And then I'm gonna

689
00:37:17,335 --> 00:37:21,337
return Card.identifierFactory. So now I'm returning a unique,

690
00:37:21,406 --> 00:37:23,740
every time you call this, it makes a unique int,

691
00:37:23,808 --> 00:37:25,975
cuz it starts at zero and makes a unique int each time.

692
00:37:26,044 --> 00:37:30,746
Now, what's interesting is I don't really seen to say Card

693
00:37:30,815 --> 00:37:34,917
dot because I'm in a static method, so I can access my

694
00:37:34,986 --> 00:37:41,524
static vars without the Card. So that's kinda cool.

695
00:37:41,593 --> 00:37:45,295
So I just want to take this little detour to show you how

696
00:37:45,363 --> 00:37:48,865
you can do these nice utility methods or whatever,

697
00:37:48,934 --> 00:37:51,601
utility vars on a type. So now let's go back over to

698
00:37:51,670 --> 00:37:54,437
our concentration, over here cuz it's got a warning, let's

699
00:37:54,506 --> 00:37:57,040
see what this warning is all about. It says immutable value

700
00:37:57,108 --> 00:38:00,710
identifier, this, was never used.

701
00:38:00,778 --> 00:38:04,747
It says consider replacing with underbar or removing it.

702
00:38:04,816 --> 00:38:07,583
Well, we can't remove it because it's the control

703
00:38:07,652 --> 00:38:11,287
variable of our for loop. But we can replace it with

704
00:38:11,355 --> 00:38:15,424
underbar. Underbar in Swift means kind of ignore this or

705
00:38:15,493 --> 00:38:17,827
I don't really care what this is cuz I'm not gonna use it.

706
00:38:17,896 --> 00:38:19,729
And we've actually used this before, do you remember?

707
00:38:19,798 --> 00:38:22,866
Back over here in our ViewController, touchCard,

708
00:38:22,934 --> 00:38:26,135
it's external name was underbar. Which means don't

709
00:38:26,203 --> 00:38:28,738
give an external name when you call this because remember

710
00:38:28,807 --> 00:38:30,873
touchCard's kind of an Objective-C thing.

711
00:38:30,942 --> 00:38:33,376
This target action, and so it didn't have external name and

712
00:38:33,444 --> 00:38:34,310
so we just said, hey,

713
00:38:34,379 --> 00:38:37,179
I don't want an external name. Similar kind of thing here in

714
00:38:37,248 --> 00:38:40,015
Concentration, we're doing a for loop, we still want to do

715
00:38:40,084 --> 00:38:42,752
this, this many times. But we don't care what identifier is

716
00:38:42,821 --> 00:38:47,657
cuz we don't use it in here anymore. Got that? Okay,

717
00:38:47,726 --> 00:38:51,193
the last thing we need to do here when we're initializing,

718
00:38:51,262 --> 00:38:54,997
it's kind of left to do, is to shuffle the cards. cuz if we

719
00:38:55,066 --> 00:38:58,334
don't shuffle the cards, then they're always going to be in

720
00:38:58,403 --> 00:39:01,136
the same order all the time. It would be really easy to

721
00:39:01,205 --> 00:39:03,473
play the game. I'm gonna leave that for your homework.

722
00:39:03,541 --> 00:39:06,676
Your job is gonna be shuffle the cards there. It's gonna

723
00:39:06,744 --> 00:39:09,879
require you to understand, again, this value type arrays,

724
00:39:09,947 --> 00:39:12,515
or value types, etc. It's a pretty good exercise to

725
00:39:12,584 --> 00:39:13,582
do that, so I'm gonna leave that for

726
00:39:13,651 --> 00:39:18,687
you. We've solved the whole initialization problem. So

727
00:39:18,756 --> 00:39:22,659
now we can go back over to our view controller over here. And

728
00:39:22,728 --> 00:39:27,063
find it. There it is. And Concentration

729
00:39:27,132 --> 00:39:31,066
right here needs to specify the number of pairs of cards.

730
00:39:31,135 --> 00:39:36,739
numberOfPairsOfCards, and what number do we put here?

731
00:39:36,807 --> 00:39:38,874
Right, I guess we could put four.

732
00:39:38,943 --> 00:39:41,577
We know we have four cards in our UI.

733
00:39:41,646 --> 00:39:43,312
But what if I wanted to add more buttons?

734
00:39:43,381 --> 00:39:45,715
Now I gotta come back here and change this four?

735
00:39:47,419 --> 00:39:50,286
Why don't we just count the number of card buttons,

736
00:39:50,354 --> 00:39:53,456
remember? Card buttons, all those buttons are in there,

737
00:39:53,524 --> 00:39:57,026
cardButtons.count. That's how many cards there are, and

738
00:39:57,095 --> 00:39:58,961
we'll just divide by two. All right, make sense?

739
00:39:59,030 --> 00:40:00,730
Let's so you can see this a little better.

740
00:40:02,500 --> 00:40:04,701
I'm just gonna take the card buttons and divide by two. So

741
00:40:04,769 --> 00:40:08,237
if I have four card buttons, that's two pairs, obviously.

742
00:40:08,306 --> 00:40:09,505
Actually I should be a little careful.

743
00:40:09,574 --> 00:40:11,707
If I had an odd number of cards,

744
00:40:11,776 --> 00:40:15,878
I probably wanna round up. So if I had three cards I'd need

745
00:40:15,947 --> 00:40:17,480
two pairs so I have four total cards.

746
00:40:17,549 --> 00:40:19,882
I'll never be able to match that third card but

747
00:40:19,951 --> 00:40:23,252
at least the game will have enough. Now, this is the right

748
00:40:23,321 --> 00:40:27,089
thing to do but I got a very serious error here. Okay,

749
00:40:27,158 --> 00:40:29,993
let's look at it. It says, cannot use Instance member

750
00:40:30,061 --> 00:40:33,830
card buttons, right here, within a property initializer.

751
00:40:33,898 --> 00:40:35,999
Oh yeah, look, var game that's a property and

752
00:40:36,067 --> 00:40:38,667
I'm initializing it, that's a property initializer.

753
00:40:38,736 --> 00:40:42,805
It says property initializers run before self is available.

754
00:40:42,873 --> 00:40:45,275
Oh, remember I told you that in Swift you have to

755
00:40:45,343 --> 00:40:48,043
completely initialize something before you can use

756
00:40:48,112 --> 00:40:50,880
anything in it, before you can access any of its bars,

757
00:40:50,949 --> 00:40:52,949
call any of its functions, anything.

758
00:40:53,018 --> 00:40:55,784
Well that obviously we're not fully initialized yet

759
00:40:55,853 --> 00:40:59,154
because we're in the process of initializing game. And

760
00:40:59,223 --> 00:41:01,023
game is the one that's initialized so

761
00:41:01,092 --> 00:41:03,893
we got a catch-22 here. How the heck are we gonna do this,

762
00:41:03,962 --> 00:41:06,228
where one depends on the other? Where one var depends

763
00:41:06,297 --> 00:41:09,565
on another. There's a couple of ways to address this.

764
00:41:09,634 --> 00:41:12,101
But I'm gonna show you kind

765
00:41:12,170 --> 00:41:16,705
of a cool one which is lazy. If you make a var lazy,

766
00:41:16,774 --> 00:41:21,143
that means it doesn't actually initialize until someone grabs

767
00:41:21,212 --> 00:41:24,881
it. Until someone tries to use it. As soon as someone tries

768
00:41:24,950 --> 00:41:27,049
to use game, then it's going to initialize it.

769
00:41:27,118 --> 00:41:31,087
Now by definition, because of that very same catch 22, no

770
00:41:31,155 --> 00:41:34,924
one can try and use game until this is fully initialized.

771
00:41:34,993 --> 00:41:39,062
So we win, it works perfectly. And lazy count as,

772
00:41:39,130 --> 00:41:43,700
this var initialized. Counting that game of getting going

773
00:41:43,768 --> 00:41:46,268
this way, so it's awesome. There is one restriction

774
00:41:46,337 --> 00:41:48,437
about lazy though, that's not so nice.

775
00:41:48,506 --> 00:41:52,909
Which is, it can not have a didSet. If you try

776
00:41:52,977 --> 00:41:55,678
to add a didSet to it, like we did here with flipCount,

777
00:41:55,747 --> 00:41:58,847
remember that? It's, you're gonna get an error here,

778
00:41:58,916 --> 00:42:02,284
this is clash declaration blah blah blah, but basically what

779
00:42:02,353 --> 00:42:05,587
it's saying here is you can't use property observers with

780
00:42:05,656 --> 00:42:07,957
a lazy var. So if you need to use a property observer there,

781
00:42:08,026 --> 00:42:09,692
you need to find out every time the game changes,

782
00:42:09,761 --> 00:42:11,260
you're going to have to do a different way.

783
00:42:11,328 --> 00:42:12,829
What are the other ways you can do it, by the way?

784
00:42:12,897 --> 00:42:14,062
Well, you're going to

785
00:42:14,131 --> 00:42:17,199
learn next week that there are methods that are called after

786
00:42:17,268 --> 00:42:20,936
all these outlets get fired up. The system will call

787
00:42:21,005 --> 00:42:23,305
a method and in there you can initialize your game.

788
00:42:23,374 --> 00:42:25,708
And maybe in the mean time you make it an optional or

789
00:42:25,776 --> 00:42:28,978
maybe even an implicitly unwrapped optional.

790
00:42:29,046 --> 00:42:30,813
A little hint to you there. But you won't need that for

791
00:42:30,882 --> 00:42:32,515
your homework though. You'll be able to do this for

792
00:42:32,583 --> 00:42:36,485
your homework. Okay, so it's good. Now we have the game,

793
00:42:36,554 --> 00:42:39,355
the big green arrow. There our controller is talking to our

794
00:42:39,423 --> 00:42:41,724
model. What do we need to do next?

795
00:42:41,793 --> 00:42:44,526
Let's go back and look at our Concentration API again, see

796
00:42:44,595 --> 00:42:47,496
what we need to do. It seems like there is two things,

797
00:42:47,565 --> 00:42:51,067
we have used this part of the API. We got these two left, so

798
00:42:51,135 --> 00:42:53,902
let's do this one, chooseCard. We got to tell

799
00:42:53,971 --> 00:42:56,539
the concentration model when our card is chosen.

800
00:42:56,607 --> 00:42:59,508
And we know exactly when that is in our controller.

801
00:42:59,577 --> 00:43:02,878
It's right here in touch card. Whenever a button calls touch

802
00:43:02,947 --> 00:43:04,613
card, we know a card's being touched.

803
00:43:04,682 --> 00:43:07,417
And instead of doing all this flip card with emoji choices

804
00:43:07,485 --> 00:43:09,985
thing right here, I'm just gonna tell my game hey,

805
00:43:10,054 --> 00:43:15,591
choose this card. Okay?

806
00:43:15,659 --> 00:43:18,594
So instead of handling it myself, I'm letting the model

807
00:43:18,663 --> 00:43:21,230
handle it. So, it's the one that's figuring it out.

808
00:43:21,299 --> 00:43:24,199
But there's something interesting to note here,

809
00:43:24,268 --> 00:43:26,869
is that when I tell the model choose this card,

810
00:43:26,938 --> 00:43:29,905
it might change the game might change. And in fact, I hope it

811
00:43:29,974 --> 00:43:31,841
does change cuz it's supposed to be doing matching and

812
00:43:31,909 --> 00:43:34,877
all kinds of stuff. So it's gonna change. So now,

813
00:43:34,946 --> 00:43:39,415
we have to update our view from the model, okay?

814
00:43:39,483 --> 00:43:41,683
Our view is now a little bit out of sync with the model,

815
00:43:41,752 --> 00:43:43,085
because when we chose this card,

816
00:43:43,154 --> 00:43:45,087
that could have caused the game to change.

817
00:43:45,156 --> 00:43:48,057
So we need a method like updateViewFromModel or

818
00:43:48,126 --> 00:43:51,594
something like that. Some kind of func down here,

819
00:43:51,663 --> 00:43:55,430
func updateViewFromModel. And what's that gonna do?

820
00:43:55,499 --> 00:43:58,534
That's gonna use the other part of this API right here.

821
00:43:58,603 --> 00:44:00,803
It's gonna look at all the cards and

822
00:44:00,871 --> 00:44:03,772
make sure all our card buttons match, right?

823
00:44:03,841 --> 00:44:06,208
Whether they're face up, whether they're matched,

824
00:44:06,277 --> 00:44:08,010
all that business. We look in the game,

825
00:44:08,079 --> 00:44:11,046
find out, and make sure our card doesn't match. All right,

826
00:44:11,115 --> 00:44:12,948
so how to we implement this updateViewFromModel?

827
00:44:13,017 --> 00:44:15,618
Well I wanna go through all the card buttons and

828
00:44:15,687 --> 00:44:19,355
look at the game and set it up appropriately. So I could do

829
00:44:19,424 --> 00:44:24,893
another for loop where I say for button in my cardButtons,

830
00:44:24,962 --> 00:44:28,330
okay? And just go through and now each button will be if we

831
00:44:28,399 --> 00:44:31,834
look at the type of this it's going to be a UI button. See?

832
00:44:31,903 --> 00:44:34,603
Because this is a sequence of buttons. Isn't that cool?

833
00:44:34,672 --> 00:44:37,306
All right? But I'm actually not gonna do that.

834
00:44:37,375 --> 00:44:40,843
I'm gonna do something else because I need to look up this

835
00:44:40,911 --> 00:44:45,147
button's index in this card thing so I'm gonna do my for

836
00:44:45,215 --> 00:44:50,018
loop by index. In the card buttons array which I could do

837
00:44:50,087 --> 00:44:54,757
with 0 dot dot less than cardButtons.count, okay.

838
00:44:54,825 --> 00:44:57,860
Everybody understand this counter range right here, but

839
00:44:57,929 --> 00:45:00,830
I'm not gonna do that either I'm gonna show you another

840
00:45:00,899 --> 00:45:05,501
way, cardButtons.indicies, okay. cardButton.indicies

841
00:45:05,570 --> 00:45:09,839
Indices is a method in array. Okay, that returs

842
00:45:09,907 --> 00:45:13,509
you a countable range of all the indexes into the array.

843
00:45:13,578 --> 00:45:16,946
In fact, if I option click on Indices, look at it's type,

844
00:45:17,014 --> 00:45:20,916
Countable range of int. Okay? So,

845
00:45:20,985 --> 00:45:23,986
that's a kind of a cool way to go through all the indices.

846
00:45:24,055 --> 00:45:26,088
And now that I have the Indices,

847
00:45:26,156 --> 00:45:29,858
I can say let button equal our cardButtons at that index.

848
00:45:29,927 --> 00:45:34,764
And let the card equal the game's cards

849
00:45:34,832 --> 00:45:38,567
at that index. So this is awesome. I've got the button.

850
00:45:38,636 --> 00:45:41,270
I've got the card. I just have to make them match up.

851
00:45:41,338 --> 00:45:44,039
So I'm going to say, if the card is faced up,

852
00:45:44,108 --> 00:45:47,009
then I'm gonna do my face up UI, which is what,

853
00:45:47,077 --> 00:45:50,512
that's this one. With the white background there.

854
00:45:50,581 --> 00:45:54,450
So let's do that. Otherwise else, if it's faced down,

855
00:45:54,519 --> 00:45:57,820
I want the orange background thing right here, that there.

856
00:45:57,889 --> 00:45:59,554
And now I don't even need flip card,

857
00:45:59,623 --> 00:46:03,525
let's get rid of flip card. Everybody,

858
00:46:03,594 --> 00:46:05,661
see what I did ther? I just made it so

859
00:46:05,730 --> 00:46:09,164
that the button matches the card. There's one other thing,

860
00:46:09,233 --> 00:46:12,634
by the way, cards can be matched. They have is matched.

861
00:46:12,703 --> 00:46:16,005
Remember, when we put that in the card, is matched. So

862
00:46:16,074 --> 00:46:19,875
I need to handle that. And the way I'm gonna do that,

863
00:46:19,944 --> 00:46:25,648
is I'm gonna make matched, cards, so

864
00:46:25,716 --> 00:46:28,917
that I can see them. If the card is matched,

865
00:46:28,986 --> 00:46:31,988
I'm just gonna take it out of the UI by making it background

866
00:46:32,056 --> 00:46:34,690
be clear instead of orange, when it's matched and

867
00:46:34,758 --> 00:46:37,259
face down. If it matches and still faced up, I don't want

868
00:46:37,327 --> 00:46:39,495
it to be clear, I want people to see you gotta a match.

869
00:46:39,564 --> 00:46:42,298
But once it turns back face down in Match I don't want it

870
00:46:42,366 --> 00:46:46,602
to show. So the way I'm gonna do that is by doing this,

871
00:46:46,671 --> 00:46:51,707
card.isMatched. Matched. Question mark.

872
00:46:51,775 --> 00:46:56,412
Either this thing or this. Does everyone know this

873
00:46:56,481 --> 00:46:59,614
question mark colon? We have it in C and other languages as

874
00:46:59,683 --> 00:47:02,518
well. So here instead of orange I want it to be clear.

875
00:47:02,586 --> 00:47:04,553
How do you get clear? Well if you go to any color

876
00:47:04,622 --> 00:47:08,023
chooser, if you look at the bottom it says opacity. That's

877
00:47:08,092 --> 00:47:11,827
how transparent the color is. So that's fully opaque, fully

878
00:47:11,896 --> 00:47:16,898
transparent. In other words, clear. So if the cards match,

879
00:47:16,967 --> 00:47:19,902
I'm gonna make it clear. Now, there's one other error here.

880
00:47:19,971 --> 00:47:23,339
It's this, emoji. Now, this emoji used to be something we

881
00:47:23,407 --> 00:47:26,375
grabbed out of this emoji choices based on the index and

882
00:47:26,444 --> 00:47:30,746
all that. I'm gonna postpone implementing that here by,

883
00:47:30,814 --> 00:47:34,950
it's calling a function emoji for card. And

884
00:47:35,019 --> 00:47:38,387
this is gonna be a function I'm gonna do down here.

885
00:47:38,455 --> 00:47:40,589
Let's scoot this up a little bit so

886
00:47:40,658 --> 00:47:44,359
you can see it, func emoji for card which is a type card, is

887
00:47:44,428 --> 00:47:48,263
gonna return an emoji and I'm gonna return question mark for

888
00:47:48,332 --> 00:47:51,167
now. We just returned question mark,

889
00:47:51,235 --> 00:47:55,304
we're gonna deal with taking these emoji choices up here.

890
00:47:55,373 --> 00:47:58,140
We're gonna put these emoji choices and eventually,

891
00:47:58,208 --> 00:48:02,110
we're going to pick one of these emojis. Randomly,

892
00:48:02,179 --> 00:48:04,847
and put it on the card, and actually I have a few more

893
00:48:04,916 --> 00:48:07,817
emojis here, little more Halloween emojis.

894
00:48:07,885 --> 00:48:10,719
So we're gonna pick one of these many emojis right here,

895
00:48:10,788 --> 00:48:11,687
and put it on the card, but for

896
00:48:11,755 --> 00:48:13,655
now, I'm just gonna do question marks. Cuz I really

897
00:48:13,724 --> 00:48:15,924
wanna get back to my UI and make sure I haven't broken

898
00:48:15,993 --> 00:48:21,197
anything with all this MVC machinations. Let's go back

899
00:48:21,265 --> 00:48:25,835
to our model and do something when a card is chosen. So

900
00:48:25,903 --> 00:48:28,437
all I'm gonna do, eventually we gotta make it match. But

901
00:48:28,506 --> 00:48:30,906
all I'm gonna do now is have the model flip the card over.

902
00:48:30,975 --> 00:48:34,209
The model's just gonna flip the card over for now, so

903
00:48:34,278 --> 00:48:37,346
here we are in chooseCard in our model. And so

904
00:48:37,415 --> 00:48:43,385
I'm gonna say, if the card at that index is face up,

905
00:48:43,454 --> 00:48:48,624
then I'm going to set the card at that index to

906
00:48:48,693 --> 00:48:56,065
be isFaceUp = false, and else, I'm going to make this true.

907
00:48:59,137 --> 00:49:02,538
True, so I'm just gonna flip the card over, everyone

908
00:49:02,607 --> 00:49:06,942
believe me that that flips the card over? Yes, just gonna,

909
00:49:07,011 --> 00:49:09,378
if it's face up, it goes face down, if it's face down,

910
00:49:09,446 --> 00:49:12,914
face up, so that's it. So now when we run our app,

911
00:49:12,983 --> 00:49:15,450
there's no emoji, everything's gonna be a question mark, but

912
00:49:15,519 --> 00:49:18,954
the card should flip over. And this is the entirety of our

913
00:49:19,023 --> 00:49:23,091
UI, here's our controller, that's all there is.

914
00:49:23,160 --> 00:49:26,696
And here's our model over here, plus we have the card,

915
00:49:26,764 --> 00:49:28,698
which is just keeping track of isMatched and

916
00:49:28,766 --> 00:49:30,632
doing that identifier. So let's take a look,

917
00:49:30,701 --> 00:49:33,302
let's run this, make sure we haven't broken anything.

918
00:49:33,370 --> 00:49:36,071
It's always nice when you make MVC and you divide it up,

919
00:49:36,140 --> 00:49:38,640
try to make your model to just do something simple.

920
00:49:38,709 --> 00:49:42,178
Just so you can make sure that your MVC is actually working.

921
00:49:42,246 --> 00:49:46,148
Here we go, sure enough, it appears to be flipping these

922
00:49:46,216 --> 00:49:50,785
cards over. Okay, excellent, so all we need,

923
00:49:50,854 --> 00:49:55,257
we have two things left to do. One, get emoji on these cards,

924
00:49:55,326 --> 00:49:59,662
two, make it actually match, make it be a real game.

925
00:49:59,730 --> 00:50:02,831
One thing is a controller thing, the emoji,

926
00:50:02,900 --> 00:50:06,768
another thing is the model. So let's go to our controller

927
00:50:06,837 --> 00:50:10,772
right here, and do this emoji thing. Now in teaching you and

928
00:50:10,841 --> 00:50:12,574
showing you this emoji thing, I'm gonna show you and

929
00:50:12,643 --> 00:50:15,644
teach you how to use a dictionary. A dictionary,

930
00:50:15,713 --> 00:50:17,012
it's very important to cloud,

931
00:50:17,081 --> 00:50:19,147
does everybody know what a dictionary is?

932
00:50:19,216 --> 00:50:21,883
Like a hash table, it's just a data structure where you can

933
00:50:21,952 --> 00:50:25,053
look something up and get a value for a certain thing.

934
00:50:25,122 --> 00:50:26,554
So we're gonna use a dictionary,

935
00:50:26,623 --> 00:50:30,592
and our dictionary looks like this, I'm gonna call it emoji,

936
00:50:30,661 --> 00:50:33,828
and its type is gonna be a dictionary.

937
00:50:33,897 --> 00:50:36,965
Now, dictionary is also a generic type like array, but

938
00:50:37,034 --> 00:50:40,035
you specify the type both of the key, which I'm gonna

939
00:50:40,103 --> 00:50:43,672
have be a int, cuz it's gonna be a card identifier, and

940
00:50:43,741 --> 00:50:48,477
the value, which is a string, an emoji.

941
00:50:48,545 --> 00:50:51,213
So this emoji dictionary, I'm going to look up the card

942
00:50:51,282 --> 00:50:54,883
identifiers to get the emoji that goes on that card.

943
00:50:54,951 --> 00:50:57,719
Everybody got that, gotta understand that before we move

944
00:50:57,788 --> 00:51:01,823
on here. So how do I create one of these dictionaries,

945
00:51:01,892 --> 00:51:04,126
exactly the same as I did with array.

946
00:51:04,195 --> 00:51:05,694
I'm just gonna do open parentheses,

947
00:51:05,763 --> 00:51:08,063
close parentheses, which creates an empty dictionary.

948
00:51:08,132 --> 00:51:12,133
So this is a dictionary of ints mapped to strings, but

949
00:51:12,202 --> 00:51:14,937
it's empty. Now down here in emoji for

950
00:51:15,006 --> 00:51:19,174
card I'm just gonna look in this dictionary and

951
00:51:19,243 --> 00:51:23,612
get a card. So let's say let chosen emoji equal, and

952
00:51:23,681 --> 00:51:26,314
here's how you look something up in a dictionary. You say

953
00:51:26,383 --> 00:51:28,817
the name of the dictionary, open square bracket,

954
00:51:28,886 --> 00:51:32,554
the thing you wanna look up. And this had better be an int,

955
00:51:32,623 --> 00:51:34,689
because this is a dictionary that looks up

956
00:51:34,758 --> 00:51:37,392
ints and gives you back strings, and this is gonna be

957
00:51:37,461 --> 00:51:40,796
a string. If I alt-click, option-click on this,

958
00:51:40,865 --> 00:51:44,299
is that going to be a string, obviously not, or I wouldn't

959
00:51:44,368 --> 00:51:47,969
be asking that question. Let's see what this chosen emoji is,

960
00:51:48,038 --> 00:51:51,773
you think it would be a string, oh, what is that? What

961
00:51:51,842 --> 00:51:56,578
type is that, anyone want to venture, I heard it out there

962
00:51:56,646 --> 00:52:01,616
whispered, an optional. It returns an optional, why is it

963
00:52:01,685 --> 00:52:04,319
returning an optional instead of returning a string? Well of

964
00:52:04,388 --> 00:52:07,222
course, because when we look something up in a dictionary,

965
00:52:07,291 --> 00:52:09,624
it might not be in there.

966
00:52:09,693 --> 00:52:11,493
The thing we looked up isn't necessarily in there, and

967
00:52:11,562 --> 00:52:15,030
if it's not there, we're gonna get back not set,

968
00:52:15,098 --> 00:52:18,066
the optional not set. If it is in there, we're gonna get

969
00:52:18,135 --> 00:52:21,036
the optional set, and it's going to be a string as its

970
00:52:21,105 --> 00:52:24,039
associated value, because of course, a string is what's in

971
00:52:24,107 --> 00:52:27,643
the dictionary. Everyone, understand that looking

972
00:52:27,711 --> 00:52:29,745
something up in the dictionary returns an optional.

973
00:52:30,881 --> 00:52:32,747
By the way, see this kind of thing,

974
00:52:32,816 --> 00:52:35,317
you know how we have that special array syntax,

975
00:52:35,385 --> 00:52:37,952
open square bracket, type, bits in the array.

976
00:52:38,021 --> 00:52:39,388
We have the same thing for dictionary,

977
00:52:39,457 --> 00:52:40,956
it looks like this, open square bracket.

978
00:52:41,025 --> 00:52:45,593
Open square bracket, the key,

979
00:52:45,662 --> 00:52:50,499
colon, the value type. So that's,

980
00:52:50,568 --> 00:52:52,834
dictionaries and strings are the most common things we're,

981
00:52:52,903 --> 00:52:55,571
data structures we're using. So we have special syntax for

982
00:52:55,639 --> 00:52:58,440
both of them, so that's what declaration of a dictionary.

983
00:52:58,508 --> 00:53:00,742
That's exactly the same as the thing I just blanked out,

984
00:53:00,811 --> 00:53:04,546
dictionary, int, string.

985
00:53:04,615 --> 00:53:08,116
So we could, since we know this returns,

986
00:53:08,185 --> 00:53:11,786
this thing is an optional, we could do if let here. But

987
00:53:11,855 --> 00:53:14,022
I'm gonna show you a different way to deal with optional. So

988
00:53:14,090 --> 00:53:16,258
you know how to do exclamation point, which we definitely

989
00:53:16,327 --> 00:53:18,394
don't wanna do here. Because, for example,

990
00:53:18,462 --> 00:53:21,163
this dictionary starts out empty, so if we do exclamation

991
00:53:21,232 --> 00:53:24,533
point here, it's gonna crash every time, so that's no good.

992
00:53:24,601 --> 00:53:26,968
And we could do if let, that would be safe, but I'm gonna

993
00:53:27,037 --> 00:53:29,471
show you another way that we often deal with something that

994
00:53:29,540 --> 00:53:32,741
might be optional. Is that we just check to see,

995
00:53:32,809 --> 00:53:37,613
if this thing does not equal nil, then we can exclamation

996
00:53:37,681 --> 00:53:43,184
point it. I can return this thing exclamation point, and

997
00:53:43,253 --> 00:53:48,423
it's safe because I checked to make sure it's not nil first.

998
00:53:48,492 --> 00:53:50,559
So that's another way to deal with optionals, just check and

999
00:53:50,628 --> 00:53:51,526
make sure it's not nil, and

1000
00:53:51,595 --> 00:53:53,829
then you can exclamation point it. And then the else,

1001
00:53:53,898 --> 00:53:57,165
I guess if we can't find the emoji in the dictionary, we'll

1002
00:53:57,234 --> 00:54:00,568
just return question mark, so we'll kinda give up and

1003
00:54:00,637 --> 00:54:04,840
just show question marks. Now, this code is so common to want

1004
00:54:04,909 --> 00:54:07,809
to get something that's an optional, and

1005
00:54:07,878 --> 00:54:11,813
if it's not, if it's set, then use it. But if it's not set,

1006
00:54:11,882 --> 00:54:14,816
do some other well-defined thing like this, but you can

1007
00:54:14,885 --> 00:54:17,819
write this with a special operator, looks like this.

1008
00:54:17,888 --> 00:54:22,591
Return, return, this thing right here.

1009
00:54:26,263 --> 00:54:29,697
But if it's nil, question mark, question mark,

1010
00:54:29,766 --> 00:54:34,369
return a different thing. So this is return this, but

1011
00:54:34,438 --> 00:54:37,305
if it's nil return this. Very common,

1012
00:54:37,374 --> 00:54:41,443
that's exactly the same code as this, exactly the same. So

1013
00:54:41,512 --> 00:54:44,879
we do not need that, everyone got that syntax,

1014
00:54:44,948 --> 00:54:49,251
it's very common to do this. So we're awesomely looking

1015
00:54:49,319 --> 00:54:52,253
up the card identifier in our emoji dictionary and

1016
00:54:52,322 --> 00:54:55,490
returning emoji, hopefully. But we never put anything

1017
00:54:55,559 --> 00:54:58,060
in that dictionary, so it's always gonna return a question

1018
00:54:58,128 --> 00:55:00,462
mark, so how do we put something in the dictionary?

1019
00:55:00,531 --> 00:55:03,899
Well, I'm gonna put them in the dictionary on demand,

1020
00:55:03,967 --> 00:55:06,435
as they are used. So every time someone asks me for

1021
00:55:06,504 --> 00:55:08,036
the emoji in a card, I'm gonna check and

1022
00:55:08,104 --> 00:55:13,007
see. If this emoji for that card is currently nil,

1023
00:55:13,076 --> 00:55:16,778
then I'm gonna put an emoji in the dictionary for that card.

1024
00:55:16,847 --> 00:55:21,049
So I'm kind of just in time loading up of this dictionary,

1025
00:55:21,118 --> 00:55:24,285
now, how am I gonna do that? I'm going to take one of these

1026
00:55:24,354 --> 00:55:27,956
at random, and put it in this dictionary, so let's get

1027
00:55:28,025 --> 00:55:33,195
a random index. I'm gonna let randomIndex equal something,

1028
00:55:33,264 --> 00:55:36,865
I'm gonna use this nice Swift function called

1029
00:55:36,934 --> 00:55:38,933
arc4rando_uniform.

1030
00:55:39,002 --> 00:55:41,603
So arc4rando_uniform is a pseudo-random number

1031
00:55:41,672 --> 00:55:44,539
generator, and it generates a random number between 0 and

1032
00:55:44,608 --> 00:55:47,075
this upper bound. Do you see it says_uppe_bound,

1033
00:55:47,144 --> 00:55:48,977
which is an unsigned int, 32 bit integer.

1034
00:55:49,046 --> 00:55:51,613
It will generate a random number between 0 and that,

1035
00:55:51,682 --> 00:55:55,350
not inclusive of that number. Which is exactly what I want,

1036
00:55:55,419 --> 00:55:58,820
where the upper bound is, how many things are in this array?

1037
00:55:58,889 --> 00:56:01,757
Cause I want an index into this array between zero and

1038
00:56:01,825 --> 00:56:05,160
however many things are in the array minus one. So here,

1039
00:56:05,228 --> 00:56:05,827
the upper bound,

1040
00:56:05,896 --> 00:56:10,198
I'm just gonna say emojiChoices.count.

1041
00:56:10,266 --> 00:56:14,236
Now this is great, but it doesn't work. I get an error,

1042
00:56:14,304 --> 00:56:17,639
and what does the error say? It says cannot convert value

1043
00:56:17,707 --> 00:56:22,344
of type int to unexpected argument type unsigned 32 bit

1044
00:56:22,413 --> 00:56:27,115
int. Our for random totally works only with unsigned ints.

1045
00:56:27,184 --> 00:56:32,354
Whereas this array's count is an int. Not an unsigned int.

1046
00:56:32,423 --> 00:56:35,924
And Swift never does automatic type conversion never.

1047
00:56:35,993 --> 00:56:38,526
It does never automatically converts from into an unsigned

1048
00:56:38,595 --> 00:56:41,696
enter from into a double. You have to explicitly convert it.

1049
00:56:41,765 --> 00:56:43,999
And so how do you convert types in Swift?

1050
00:56:44,068 --> 00:56:45,267
This is why I'm showing you this so

1051
00:56:45,336 --> 00:56:47,402
that you'll know how to convert types in Swift

1052
00:56:47,470 --> 00:56:50,072
you have to create a new thing and

1053
00:56:50,140 --> 00:56:53,007
use the initializer of that new thing to create one. So

1054
00:56:53,076 --> 00:56:58,246
here, I wanna create A uint32, an unsigned int 32. So I have

1055
00:56:58,315 --> 00:57:03,485
to call uint32 initializer to create a uint32. Luckily,

1056
00:57:03,554 --> 00:57:07,389
uint32, which is a struct, by the way, just like INT,

1057
00:57:07,457 --> 00:57:09,957
just like string, just like array, just like dictionary,

1058
00:57:10,026 --> 00:57:12,894
just like card. These are all structs.

1059
00:57:12,963 --> 00:57:15,630
It has an initializer that takes an int.

1060
00:57:15,699 --> 00:57:19,734
Exactly what I want, okay? So I can create a UInt32 by

1061
00:57:19,803 --> 00:57:21,636
passing it an int emojiChoices.

1062
00:57:21,705 --> 00:57:23,905
That's why it's suggesting this fix right here.

1063
00:57:23,974 --> 00:57:27,175
So I'm gonna do that, fix. You see what it did? UInt32,

1064
00:57:27,244 --> 00:57:30,345
open parentheses. The argument to its init is an Int.

1065
00:57:30,414 --> 00:57:33,015
It knows how to do that. Now we're not there yet.

1066
00:57:33,083 --> 00:57:35,517
Because look at the return value here, randomIndex.

1067
00:57:35,585 --> 00:57:38,086
It's also an unsigned integer, and that's no good.

1068
00:57:38,155 --> 00:57:41,623
Because I want to use it as an index into this array. And

1069
00:57:41,692 --> 00:57:43,791
we know that indexes are not unsigned ints,

1070
00:57:43,860 --> 00:57:47,495
although they probably should be. They are ints. Okay,

1071
00:57:47,564 --> 00:57:50,766
just for mostly for backwards compatibility issues.

1072
00:57:50,834 --> 00:57:55,203
So I need to convert this whole thing to an int, luckily

1073
00:57:55,272 --> 00:57:59,974
int Has an initializer that will take an unsigned int and

1074
00:58:00,043 --> 00:58:04,913
turn it into an int. Okay, so now I have random index here.

1075
00:58:04,981 --> 00:58:08,583
It's an int, it's suitable for indexing into this array.

1076
00:58:08,652 --> 00:58:12,620
It's a random index in there. So to get it, I can say emoji

1077
00:58:12,689 --> 00:58:16,892
sub card.identifier. Now to put something in A dictionary.

1078
00:58:16,960 --> 00:58:20,795
You just say equals and the thing you want. Emoji,

1079
00:58:20,864 --> 00:58:25,266
choices, sub, random, index. But I'm not, this is not quite

1080
00:58:25,335 --> 00:58:27,769
what I'm gonna do. This would work kind of.

1081
00:58:27,838 --> 00:58:31,006
The only problem with this is, I could get two identifiers

1082
00:58:31,075 --> 00:58:34,576
that use the same emoji. So instead of just grabbing

1083
00:58:34,645 --> 00:58:38,580
something out here, I'm gonna remove it. Okay, when I use

1084
00:58:38,649 --> 00:58:40,915
one of these emojis, I'm going to remove it out of here so

1085
00:58:40,984 --> 00:58:44,586
I never use it again. So to do that, I'm going to use

1086
00:58:44,655 --> 00:58:47,288
a different method in array than subscripting called

1087
00:58:47,357 --> 00:58:52,460
remove at. And I'm just gonna remove at the random index.

1088
00:58:52,529 --> 00:58:55,797
So remove at returns the thing it removed. And so it's gonna

1089
00:58:55,865 --> 00:58:58,266
pick one of these emojis out of here and return it.

1090
00:58:58,335 --> 00:59:01,370
And I'm gonna put it in the dictionary. Everybody got

1091
00:59:01,438 --> 00:59:04,339
that? Now there's only one other thing here,

1092
00:59:04,407 --> 00:59:07,442
which is what if emojiChoices.count is zero.

1093
00:59:07,511 --> 00:59:10,045
In other words, what if I've used all the emoji

1094
00:59:10,113 --> 00:59:12,447
in emojiChoices, I've pulled them all out of there?

1095
00:59:12,516 --> 00:59:15,283
That's going to cause a problem. ran, arc4random can't

1096
00:59:15,352 --> 00:59:18,687
take zero because it goes from zero To that number minus 1.

1097
00:59:18,755 --> 00:59:21,522
And it's an unsigned int, so it can't be a minus number.

1098
00:59:21,591 --> 00:59:23,591
So we're gonna have to protect against that case.

1099
00:59:23,660 --> 00:59:28,029
So I'm gonna say if emojichoices.count

1100
00:59:28,097 --> 00:59:30,732
is greater than 0, then I can grab

1101
00:59:30,801 --> 00:59:33,635
an emoji out of there and use it. But if

1102
00:59:33,704 --> 00:59:36,971
it's less than that, if it's equal 0 then I can't do this.

1103
00:59:37,040 --> 00:59:39,975
And then I'm stuck with question mark down here. By

1104
00:59:40,043 --> 00:59:42,477
the way cool thing in Swift, you see how we have back to

1105
00:59:42,546 --> 00:59:46,881
back ifs here. You can put back to back ifs on the same

1106
00:59:46,950 --> 00:59:51,253
line by just separating them with comma, okay,

1107
00:59:51,321 --> 00:59:54,155
then you don't need the embedded ifs right there.

1108
00:59:54,224 --> 00:59:56,858
And it's nice especially when things are related, like look

1109
00:59:56,927 --> 00:59:59,761
at how this cut line of code reads. If the emoji for

1110
00:59:59,829 --> 01:00:02,530
this card identifier is not set and

1111
01:00:02,599 --> 01:00:08,736
if we have emojiChoices, then go get one, All right?

1112
01:00:08,805 --> 01:00:11,272
Okay, so let's see if this works. Let's go and run and

1113
01:00:11,341 --> 01:00:14,675
see if we're grabbing a random emoji out of there and putting

1114
01:00:14,744 --> 01:00:18,513
them in one of our four cards. It's pseudorandom by the way,

1115
01:00:18,582 --> 01:00:20,548
so you're gonna see that it's not super random.

1116
01:00:20,617 --> 01:00:22,183
But anyway, all right, so let's look.

1117
01:00:22,252 --> 01:00:26,154
Oh yeah, look, we got a random emoji. Oh there's another one,

1118
01:00:26,223 --> 01:00:29,791
little candy, hopefully these two are the same, yay!. Okay

1119
01:00:29,860 --> 01:00:33,161
so it's working. Okay it's looking it up by identifier,

1120
01:00:33,230 --> 01:00:36,164
picking emoji and using that emoji for that identifier

1121
01:00:36,233 --> 01:00:38,466
on all cards. And hopefully it's random. Let's stop again.

1122
01:00:38,535 --> 01:00:41,603
So we've got the devil guy, and the candy here.

1123
01:00:41,671 --> 01:00:45,440
Cross your fingers that pseudo random generator does it,

1124
01:00:45,509 --> 01:00:48,643
let's see. Uh oh, devil guy, oh we got the cat,

1125
01:00:48,711 --> 01:00:52,280
the scared cat or whatever that is, the screaming cat. So

1126
01:00:52,349 --> 01:00:54,182
we're getting random, this looks like it's working.

1127
01:00:54,251 --> 01:00:56,217
So we've got our UI fully functional here.

1128
01:00:56,286 --> 01:00:58,687
So the only thing that's left to do now

1129
01:00:58,756 --> 01:01:00,354
is make this thing play Concentration and

1130
01:01:00,423 --> 01:01:02,457
that's purely a model thing. So to make

1131
01:01:02,525 --> 01:01:05,594
that work I'm going to bring up my model. And

1132
01:01:05,662 --> 01:01:07,929
I'm only going to put code here in my model.

1133
01:01:07,998 --> 01:01:10,699
Right now it flips cards over. We'll stop that.

1134
01:01:10,768 --> 01:01:13,869
Instead we're gonna have it play the game. And

1135
01:01:13,937 --> 01:01:16,337
as part of implementing this, I'm gonna use an optional.

1136
01:01:16,406 --> 01:01:17,872
Because I know you're all still except for

1137
01:01:17,941 --> 01:01:20,342
this guy who asked this great question. You're all still not

1138
01:01:20,410 --> 01:01:21,877
quite sure I understand the optional thing.

1139
01:01:21,945 --> 01:01:24,946
So here's a chance, case where I'm gonna use an optional

1140
01:01:25,014 --> 01:01:27,849
as part of my Fundamental semantic implementation

1141
01:01:27,918 --> 01:01:30,451
of this method. So here we go.

1142
01:01:30,520 --> 01:01:34,155
The first thing I'm gonna do when a card is chosen is

1143
01:01:34,224 --> 01:01:37,458
I'm gonna ignore a card that's already been matched. So

1144
01:01:37,527 --> 01:01:39,994
if you choose a card that's on the board that's already been

1145
01:01:40,063 --> 01:01:42,029
matched to another card, I'm just gonna ignore it. So

1146
01:01:42,098 --> 01:01:46,735
I'm gonna say if the card that you chose, card of the index,

1147
01:01:46,804 --> 01:01:50,739
isMatched. Then I'm not gonna do this, so

1148
01:01:50,808 --> 01:01:53,107
I'm gonna say if it's not Matched then do it,

1149
01:01:53,176 --> 01:01:56,811
if it is Matched then don't do this. This notch,

1150
01:01:56,880 --> 01:01:59,481
just like any other language means not, the opposite of

1151
01:01:59,550 --> 01:02:02,250
this Bool. I'm gonna ignore all Matched cards.

1152
01:02:02,319 --> 01:02:05,519
Now what am I gonna do? There's three cases here

1153
01:02:05,588 --> 01:02:10,091
that can happen. One, no cards are face up. If no cards

1154
01:02:10,159 --> 01:02:12,894
are face up when I choose a card it just flips it over.

1155
01:02:12,962 --> 01:02:16,764
That's all it does. Another option is two cards are face

1156
01:02:16,833 --> 01:02:19,900
up, either matching or not matching. If that's true,

1157
01:02:19,969 --> 01:02:22,704
when I choose another card it needs to flip those cards face

1158
01:02:22,773 --> 01:02:27,541
down cuz I'm starting a new match now. The third option is

1159
01:02:27,610 --> 01:02:30,978
there's one card face up and I choose some other card.

1160
01:02:31,047 --> 01:02:33,882
Now I need to match. I need to see if they match.

1161
01:02:33,950 --> 01:02:37,585
So those are the three options. So I want to

1162
01:02:37,654 --> 01:02:40,455
really keep track of the option where there's one card

1163
01:02:40,524 --> 01:02:42,691
face up because that's where I really have to do the work.

1164
01:02:42,760 --> 01:02:44,392
I have to try and see if they match. So

1165
01:02:44,461 --> 01:02:47,662
I'm going to create a var to keep track if there is one and

1166
01:02:47,730 --> 01:02:49,363
only one card face up.

1167
01:02:49,432 --> 01:02:53,067
I'm going to call it indexOfOneAndOnlyFaceUpCard

1168
01:02:53,136 --> 01:02:59,541
and of course its an index so its going to be an int.

1169
01:02:59,609 --> 01:03:03,978
Now whats the value of the indexOfOneAndOnlyFaceUpCard if

1170
01:03:04,047 --> 01:03:10,218
no cards are face up? What's the value of that if two

1171
01:03:10,286 --> 01:03:14,155
cards are face up? Ah, interesting.

1172
01:03:14,224 --> 01:03:19,393
I think this wants to be optional. You see why, because

1173
01:03:19,462 --> 01:03:22,197
in those cases where there's not one index of a one and

1174
01:03:22,266 --> 01:03:25,133
only face card, then this going to be not set,

1175
01:03:25,201 --> 01:03:28,603
cause there is not one and only face card. So this

1176
01:03:28,672 --> 01:03:32,473
is a great use of optionals right here. So all the time in

1177
01:03:32,542 --> 01:03:35,076
my game, when there's one and only one face up card, this

1178
01:03:35,145 --> 01:03:37,712
going to tell me the index of it so I can match against it.

1179
01:03:37,780 --> 01:03:40,114
And all the other times this is gonna be nill and

1180
01:03:40,183 --> 01:03:42,550
I'm gonna know I don't have to do any work. I don't have to

1181
01:03:42,619 --> 01:03:44,652
do any matching because there's no card to match

1182
01:03:44,721 --> 01:03:47,522
against. So what does the code look like to use this?

1183
01:03:47,590 --> 01:03:50,591
I'm going to say if I can let a match index,

1184
01:03:50,660 --> 01:03:54,295
which is a local variable, equal this index of one and

1185
01:03:54,364 --> 01:03:57,665
only face up card right here, then I have something to

1186
01:03:57,734 --> 01:04:01,135
match. By the way, I wanna make sure that that match

1187
01:04:01,204 --> 01:04:06,207
index of that thing is not equal to the card you chose.

1188
01:04:06,276 --> 01:04:08,709
If there's only, only, if there's one and

1189
01:04:08,778 --> 01:04:10,979
only one face of card and you chose that,

1190
01:04:11,047 --> 01:04:13,748
it's going to ignore that. You have to choose a different

1191
01:04:13,817 --> 01:04:19,220
card. This inside this curly brace right here is, you know,

1192
01:04:19,289 --> 01:04:24,892
check if cards match. And then outside right here is what?

1193
01:04:24,961 --> 01:04:28,129
Either no cards or

1194
01:04:28,198 --> 01:04:33,734
two cards are face up, so I can't match. So

1195
01:04:33,803 --> 01:04:36,638
in that case I'm gonna need to turn the cards face down and

1196
01:04:36,706 --> 01:04:38,673
have the card you chose be the only face up card.

1197
01:04:38,741 --> 01:04:41,008
And then I'm gonna set it to be the index of the one and

1198
01:04:41,077 --> 01:04:43,311
only face up card.

1199
01:04:43,379 --> 01:04:45,714
Let's do all that. Let's check if the cards match,

1200
01:04:45,782 --> 01:04:52,786
really easy if the cards match index its identifier

1201
01:04:52,855 --> 01:04:57,592
equals the cards of the index you chose. This is choose card

1202
01:04:57,661 --> 01:05:01,596
at index. If they match, then I'm gonna mark them matched.

1203
01:05:01,664 --> 01:05:06,501
Cards of match index is matched and

1204
01:05:06,570 --> 01:05:11,772
the cards that you chose is matched.

1205
01:05:11,841 --> 01:05:18,412
So I matched them, excellent. Now, even if they don't match,

1206
01:05:18,481 --> 01:05:21,549
what happens when I chose that second card right there? Two

1207
01:05:21,617 --> 01:05:26,621
things happen, one, I gotta flip up the card you chose.

1208
01:05:26,689 --> 01:05:29,023
Cuz you chose a card that was face down, right there so

1209
01:05:29,092 --> 01:05:32,193
I'm gonna say cards sub index is...

1210
01:05:33,697 --> 01:05:37,198
Is face up is true, cuz you chose a card,

1211
01:05:37,267 --> 01:05:39,400
I'm flipping it up of course. And number two and

1212
01:05:39,469 --> 01:05:43,337
most importantly the index of the one and only face up card

1213
01:05:43,406 --> 01:05:48,542
equals nil. Because now there are two matched cards,

1214
01:05:48,611 --> 01:05:51,979
two, matched or unmatched, two face up cards. So

1215
01:05:52,048 --> 01:05:55,549
there is not a one and only face up card. So it's nil, so

1216
01:05:55,618 --> 01:05:58,653
it's perfectly legal to to set an optional to nil. So that's

1217
01:05:58,721 --> 01:06:00,755
what we do if the cards match, that's all we have to do.

1218
01:06:00,823 --> 01:06:03,024
Now here we either have no cards or

1219
01:06:03,093 --> 01:06:04,792
two cards are face up. In this case,

1220
01:06:04,861 --> 01:06:07,795
I'm gonna turn all cards face down. Now they might already

1221
01:06:07,864 --> 01:06:10,798
all be face down but so it's a little of wasted work.

1222
01:06:10,867 --> 01:06:15,636
I'm just gonna go for flip down index in, what?

1223
01:06:15,705 --> 01:06:21,943
In my cards' indices. Cards.indices,

1224
01:06:22,012 --> 01:06:24,679
that's all, that's a countable range. Remember,

1225
01:06:24,747 --> 01:06:29,884
this is a countable range right here, of all the indexes

1226
01:06:29,952 --> 01:06:33,321
of the flip, in my cards. So for each one of the cards,

1227
01:06:33,389 --> 01:06:39,527
I'm gonna say card at the flipDownIndex.isFaceup= false.

1228
01:06:39,596 --> 01:06:43,131
I just turned every single card on the board face down.

1229
01:06:43,199 --> 01:06:45,766
But now you've chose a card, so I'm gonna turn that card

1230
01:06:45,835 --> 01:06:53,541
that you just chose back to face up. .isFaceUp = true and

1231
01:06:53,610 --> 01:06:56,944
of course since I just turned all the cards face down and

1232
01:06:57,013 --> 01:07:00,414
turned one card faced up, what is the index of the one and

1233
01:07:00,483 --> 01:07:04,752
only face up card? It's this index. I just turned it

1234
01:07:04,821 --> 01:07:08,256
faced up so, by definition it's the only card.

1235
01:07:08,325 --> 01:07:10,858
And this ladies and gentlemen what do we got here? Oh this

1236
01:07:10,926 --> 01:07:15,229
is cardsindex.identifier got to compare the identifiers.

1237
01:07:15,298 --> 01:07:18,532
This is the entirety of the concentration game logic,

1238
01:07:18,601 --> 01:07:21,502
that's it, that's all that's necessary.

1239
01:07:21,571 --> 01:07:23,437
And can you see how having this optional

1240
01:07:23,506 --> 01:07:26,407
right here kinda made it very simple and straightforward?

1241
01:07:26,475 --> 01:07:29,810
Because it's easy for me to track the card I want it to

1242
01:07:29,879 --> 01:07:32,379
match against all the time. And it was easy for

1243
01:07:32,448 --> 01:07:35,183
me to tell whether there was one to match it against or

1244
01:07:35,251 --> 01:07:37,518
not, all contained in one little variable that had a lot

1245
01:07:37,587 --> 01:07:41,856
of information it it. That's it, let's go see if our

1246
01:07:41,924 --> 01:07:44,325
app is working. It should just work, I mean once you make

1247
01:07:44,393 --> 01:07:47,561
the model, do what its suppose to do the UI doesn't care.

1248
01:07:47,630 --> 01:07:49,630
It's just presenting what the model has, so

1249
01:07:49,699 --> 01:07:52,200
it should just work. So let's try it here. All right,

1250
01:07:52,268 --> 01:07:56,837
we've got this, the cat, oh, there's the screaming face.

1251
01:07:56,906 --> 01:07:58,873
Now what should happen when I click another card?

1252
01:07:58,941 --> 01:08:00,741
It should flip them all face down.

1253
01:08:00,810 --> 01:08:02,276
It didn't match, this didn't match, so

1254
01:08:02,345 --> 01:08:05,213
it should flip these all face down. Turn the new one face

1255
01:08:05,281 --> 01:08:07,615
up, and now that optional's gonna be set. So

1256
01:08:07,684 --> 01:08:10,418
let's try it. Sure enough it turned them all face down and

1257
01:08:10,486 --> 01:08:14,589
turned this one up. Now what happens if I choose a match?

1258
01:08:14,657 --> 01:08:17,458
Now they've both been marked matched. Now the next time I

1259
01:08:17,527 --> 01:08:19,760
click on a card, it's gonna turn them face down.

1260
01:08:19,829 --> 01:08:24,365
They're gonna be both face down and matched, so

1261
01:08:24,434 --> 01:08:28,303
they're gonna get a clear background and

1262
01:08:28,371 --> 01:08:32,973
we're not gonna be able to see them, watch.

1263
01:08:33,042 --> 01:08:38,312
Now that the game is done. Now in your homework you're gonna

1264
01:08:38,381 --> 01:08:40,882
add a new game button which is what you would press at this

1265
01:08:40,950 --> 01:08:46,354
point. I won't play another game. Last thing

1266
01:08:46,423 --> 01:08:51,492
to do here and we have time luckily is to add more cards.

1267
01:08:51,561 --> 01:08:54,262
Because four cards is kind of a boring game so

1268
01:08:54,331 --> 01:08:59,400
let's go here to our UI. We've got our UI. I made my

1269
01:09:01,771 --> 01:09:05,673
buttons here be 80 points wide which I kinda recommend you do

1270
01:09:05,742 --> 01:09:08,776
for your homework. Because 80 points wide,

1271
01:09:08,845 --> 01:09:12,747
they fit really nice four across okay? Let's put them

1272
01:09:12,816 --> 01:09:15,816
up,now I'm gonna use the little blue lines to help me

1273
01:09:15,885 --> 01:09:21,389
place them here. If you use the blue lines look,

1274
01:09:21,458 --> 01:09:24,559
four of them at 80 points each fit right across. And

1275
01:09:24,627 --> 01:09:26,126
then I'm gonna make some more. I'm gonna select them and

1276
01:09:26,195 --> 01:09:29,496
copy paste. Use the blinds, the blue lines paste some

1277
01:09:29,565 --> 01:09:31,466
more, let's have 12 of them here.

1278
01:09:33,202 --> 01:09:36,136
And I need to make sure that everything is connected so

1279
01:09:36,205 --> 01:09:38,839
let's look at like touch card. Hey, they're all sending touch

1280
01:09:38,908 --> 01:09:43,411
card, great. How about card buttons? When we copy and

1281
01:09:43,479 --> 01:09:47,682
paste it doesn't put them into that card buttons outlet

1282
01:09:47,751 --> 01:09:49,584
array of buttons, so we need to do that.

1283
01:09:49,652 --> 01:09:51,351
So I'm just going to do ctrl+drag.

1284
01:09:51,420 --> 01:09:56,557
Now if you really had 12 cards or more than 12 cards, in real

1285
01:09:56,626 --> 01:09:59,527
life you'd probably wouldn't use an outlet collection.

1286
01:09:59,595 --> 01:10:03,064
You would probably go in your code and go find all these

1287
01:10:03,133 --> 01:10:04,698
things, you could probably do it all in one or

1288
01:10:04,767 --> 01:10:07,301
two lines of code actually. But you really haven't learned

1289
01:10:07,370 --> 01:10:10,537
enough from me about how the view hierarchy works and

1290
01:10:10,606 --> 01:10:13,007
all these things to do that. So for your homework

1291
01:10:13,075 --> 01:10:15,443
you're just gonna have to be doing some control dragging

1292
01:10:15,512 --> 01:10:19,380
like I am to hook them all up. They're all hooked up,

1293
01:10:19,448 --> 01:10:22,183
they're all hooked up. Our flip count label's hooked up.

1294
01:10:22,252 --> 01:10:25,286
Our UI looks all set. I haven't changed anything but

1295
01:10:25,354 --> 01:10:30,324
that. I didn't go change any code anywhere. Okay, I just

1296
01:10:30,392 --> 01:10:32,827
put more buttons in my UI. And because I built this nice,

1297
01:10:32,895 --> 01:10:37,799
flexible UI that can really handle any number of cards,

1298
01:10:37,867 --> 01:10:46,374
this should just work. Here we go,

1299
01:10:46,443 --> 01:10:49,977
let's try. We got candy, apple,

1300
01:10:50,046 --> 01:10:54,882
no match. I have bat, no match.

1301
01:10:54,951 --> 01:11:01,021
How about pumpkin? Oh candy I think I remember candy,

1302
01:11:01,090 --> 01:11:04,725
was it maybe right here? Yes,

1303
01:11:04,794 --> 01:11:07,795
woo ho we found the candy it was right next to each other.

1304
01:11:07,863 --> 01:11:11,365
Let's try something else. Okay how about this one, apple,

1305
01:11:11,433 --> 01:11:16,604
no.,no match. Oh, apple oh, this is a pretty easy game.

1306
01:11:16,673 --> 01:11:18,505
I don't know why everyone thinks Concentration's so

1307
01:11:18,574 --> 01:11:20,174
hard, look at that. Okay,

1308
01:11:20,242 --> 01:11:24,312
all done. Okay so why is this game so easy?

1309
01:11:24,380 --> 01:11:27,882
Well, because you guys have not done your homework yet,

1310
01:11:27,951 --> 01:11:31,719
which if you remember back here Concentration we have

1311
01:11:31,788 --> 01:11:37,124
this little to do. To do by the way is a special comment.

1312
01:11:37,193 --> 01:11:40,194
If you look at the top line of your thing right here, which

1313
01:11:40,262 --> 01:11:42,797
shows you which file you're choosing. It also shows you

1314
01:11:42,865 --> 01:11:46,533
within that file with all your methods and properties and

1315
01:11:46,602 --> 01:11:51,906
if you put //to do, it shows up. See shuffle the cards.

1316
01:11:51,975 --> 01:11:55,242
All right, see you on Monday. >> For

1317
01:11:55,311 --> 01:12:04,718
more, please visit us at Stanford.edu.
>> 更多课程详见 stanford.edu
